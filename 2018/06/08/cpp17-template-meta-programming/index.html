<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="初步尝试C++模版元编程。元编程考虑的是编译时的逻辑，和运行时不同，有点不太习惯，要时刻记住编译时!">
<meta property="og:type" content="article">
<meta property="og:title" content="C++使用模版进行元编程">
<meta property="og:url" content="http://yoursite.com/2018/06/08/cpp17-template-meta-programming/index.html">
<meta property="og:site_name" content="Yuanguo&#39;s Blog">
<meta property="og:description" content="初步尝试C++模版元编程。元编程考虑的是编译时的逻辑，和运行时不同，有点不太习惯，要时刻记住编译时!">
<meta property="og:locale">
<meta property="article:published_time" content="2018-06-08T20:15:30.000Z">
<meta property="article:modified_time" content="2025-07-10T09:32:33.489Z">
<meta property="article:author" content="Yuanguo Huo">
<meta property="article:tag" content="template">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2018/06/08/cpp17-template-meta-programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>C++使用模版进行元编程 | Yuanguo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yuanguo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/08/cpp17-template-meta-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.gif">
      <meta itemprop="name" content="Yuanguo Huo">
      <meta itemprop="description" content="A little better than yesterday">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanguo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++使用模版进行元编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="Created: 2018-06-08 20:15:30" itemprop="dateCreated datePublished" datetime="2018-06-08T20:15:30+00:00">2018-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="Modified: 2025-07-10 09:32:33" itemprop="dateModified" datetime="2025-07-10T09:32:33+00:00">2025-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">所属分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          
            <span id="/2018/06/08/cpp17-template-meta-programming/" class="post-meta-item leancloud_visitors" data-flag-title="C++使用模版进行元编程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2018/06/08/cpp17-template-meta-programming/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/08/cpp17-template-meta-programming/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>初步尝试C++模版元编程。元编程考虑的是编译时的逻辑，和运行时不同，有点不太习惯，要时刻记住<strong>编译时</strong>!</p>
<a id="more"></a>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<h1 id="查找一个类型T-1"><a href="#查找一个类型T-1" class="headerlink" title="查找一个类型T (1)"></a>查找一个类型T (1)</h1><p>假设有一个类型列表：<code>char</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>double</code>；要找<code>float</code>在这个序列中的位置(从0开始，结果应该是3)：</p>
<h2 id="初步尝试-1-1"><a href="#初步尝试-1-1" class="headerlink" title="初步尝试 (1.1)"></a>初步尝试 (1.1)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Needle</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">size_t</span> <span class="title">Find</span>(<span class="title">Needle</span>, <span class="title">Needle</span>, <span class="title">Ts</span>...) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Needle</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">size_t</span> <span class="title">Find</span>(<span class="title">Needle</span>, <span class="title">T</span>, <span class="title">Ts</span>...) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + Find(Needle(), Ts()...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span>  target = <span class="number">100.0</span>;</span><br><span class="line">  <span class="keyword">char</span>   c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">short</span>  s = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>    i = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">float</span>  f = <span class="number">3.0</span>;</span><br><span class="line">  <span class="keyword">double</span> d = <span class="number">4.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Find(target, c, s, i, f, d) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行（本文所有例子只在linux/gcc环境测试过），果然输出3！原理是什么呢？</p>
<p>模版函数Find其实是一个递归，不同的是，<strong>这个递归是在编译时运行的</strong>！</p>
<ul>
<li><code>Find(Needle, Needle, Ts...)</code>是递归出口：它的特点是前2个参数类型相同！只要满足这个条件，就递归结束，返回0；注意，参数的值根本没有用，只考虑参数的类型：<code>Needle</code>, <code>Needle</code>, <code>Ts...</code>；</li>
<li><code>Find(Needle, T, Ts...)</code>是递归中间过程：调用时执行，不，确切的说，是<strong>编译调用语句时执行</strong>；</li>
</ul>
<p>例如，编译器编译<code>main()</code>函数中的语句<code>Find(target, c, s, i, f, d)</code>：</p>
<ul>
<li>因为<code>target</code>和<code>c</code>类型不同，所以匹配<code>Find(Needle, T, Ts...)</code>：<ul>
<li><code>Needle=float</code>, <code>T=char</code>, <code>...Ts=&#123;short, int, float, double&#125;</code>；</li>
<li><strong>编译器生成一个函数</strong><code>Find(float, char, short, int, float, double)</code>；</li>
<li>递归：把<code>T=char</code>略去，<code>1 + Find(float变量，short变量，int变量，float变量，double变量)</code>；注意这里函数参数都是临时变量，原来的<code>target</code>, <code>s</code>, <code>i</code>, <code>f</code>, <code>d</code>都丢了：<strong>它们本来就一点用也没有，还会带来问题，后面再填这个坑</strong>！</li>
</ul>
</li>
<li>再看<code>Find(float变量，short变量，int变量，float变量，double变量)</code>，因为前两个参数类型还是不同，继续匹配<code>Find(Needle, T, Ts...)</code>：<ul>
<li><code>Needle=float</code>, <code>T=short</code>, <code>...Ts=&#123;int, float, double&#125;</code>；</li>
<li><strong>编译器生成函数</strong><code>Find(float, short, int, float, double)</code>；</li>
<li>递归：把<code>T=short</code>略去，<code>1 + 1 + Find(float变量，int变量，float变量，double变量)</code>；</li>
</ul>
</li>
<li>继续<code>Find(float变量，int变量，float变量，double变量)</code>，还是匹配<code>Find(Needle, T, Ts...)</code>：<ul>
<li><code>Needle=float</code>, <code>T=int</code>, <code>...Ts=&#123;float, double&#125;</code>；</li>
<li><strong>编译器生成函数</strong><code>Find(float, int, float, double)</code>；</li>
<li>递归：把<code>T=int</code>略去，<code>1 + 1 + 1 + Find(float变量，float变量，double变量)</code>；</li>
</ul>
</li>
<li>最后<code>Find(float变量，float变量，double变量)</code>的前2个参数类型一样，匹配递归出口<code>Find(Needle, Needle, Ts...)</code>：<ul>
<li><code>Needle=float</code>, <code>Needle=float</code>, <code>...Ts=&#123;double&#125;</code></li>
<li><strong>编译器生成函数</strong><code>Find(float, float, double)</code>；</li>
<li>它返回0；</li>
</ul>
</li>
</ul>
<p>所以，结果是3。看起来很不错！</p>
<h2 id="变量值的问题-1-2"><a href="#变量值的问题-1-2" class="headerlink" title="变量值的问题 (1.2)"></a>变量值的问题 (1.2)</h2><p>前面说过，<code>target</code>, <code>s</code>, <code>i</code>, <code>f</code>, <code>d</code>这些变量会带来问题。什么问题呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Foo    <span class="title">target</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">char</span>   c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">short</span>  s = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>    i = <span class="number">2</span>;</span><br><span class="line">  <span class="function">Foo    <span class="title">f</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="keyword">double</span> d = <span class="number">4.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Find(target, c, s, i, f, d) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译失败：error: no matching function for call to Foo::Foo()！显而易见：<code>Foo</code>没有默认构造函数，<code>Find()</code>递归过程中（<strong>编译器编译过程中</strong>），<code>Needle()</code>找不到合适的构造函数！</p>
<p>其实还隐藏一个问题：假如<code>Foo</code>有默认构造函数但很重，例如分配大量内存，打开文件，甚至建立socket连接，就会导致严重的性能问题！前面也说过，那些变量值一点用也没有。</p>
<p>怎么办呢？其实只需要类型，想办法<strong>只传递类型就可以了</strong>！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Find(Type&lt;Foo&gt;(),</span><br><span class="line">                    Type&lt;<span class="keyword">char</span>&gt;(),</span><br><span class="line">                    Type&lt;<span class="keyword">short</span>&gt;(),</span><br><span class="line">                    Type&lt;<span class="keyword">int</span>&gt;(),</span><br><span class="line">                    Type&lt;Foo&gt;(),</span><br><span class="line">                    Type&lt;<span class="keyword">double</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据模版的特性, <code>Type&lt;Foo&gt;</code>, <code>Type&lt;char&gt;</code>, <code>Type&lt;short&gt;</code>等都是不同的struct/class！这些class都没有任何资源，且都有默认构造函数（没有任何构造函数的话，编译器会提供默认版本），所以完美的解决了传值的问题。本质上，是传<code>Type&lt;T&gt;</code>类型的值，但值没有用，有用的是类型！一言以蔽之：<code>Type</code><strong>用于包装类型，便于传递类型信息</strong>！</p>
<h2 id="完善-1-3"><a href="#完善-1-3" class="headerlink" title="完善 (1.3)"></a>完善 (1.3)</h2><p>为了学习更多模版元编程的知识，加入一点优化：假如列表中不包含target类型或者包含多个，编译报错！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">Contains</span> = <span class="title">std</span>:</span>:disjunction&lt;<span class="built_in">std</span>::is_same&lt;T, Ts&gt;...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Needle</span>, <span class="title">class</span>... <span class="title">Ts</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">size_t</span> <span class="title">Find</span>(<span class="title">Needle</span>, <span class="title">Needle</span>, <span class="title">Ts</span>...) &#123;</span></span><br><span class="line">  <span class="comment">//确保：匹配之后不会再有相同类型！</span></span><br><span class="line">  <span class="keyword">static_assert</span>(!Contains&lt;Needle, Ts...&gt;(), <span class="string">&quot;Duplicate element type&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//编译报错：static assertion failed: Type not found</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  static_assert(Contains&lt;Type&lt;Foo&gt;,</span></span><br><span class="line"><span class="comment">                         Type&lt;char&gt;,</span></span><br><span class="line"><span class="comment">                         Type&lt;short&gt;,</span></span><br><span class="line"><span class="comment">                         Type&lt;int&gt;,</span></span><br><span class="line"><span class="comment">                         Type&lt;double&gt;&gt;(),</span></span><br><span class="line"><span class="comment">                  &quot;Type not found&quot;);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static_assert</span>(Contains&lt;Type&lt;Foo&gt;,</span><br><span class="line">                         Type&lt;<span class="keyword">char</span>&gt;,</span><br><span class="line">                         Type&lt;<span class="keyword">short</span>&gt;,</span><br><span class="line">                         Type&lt;<span class="keyword">int</span>&gt;,</span><br><span class="line">                         Type&lt;Foo&gt;,</span><br><span class="line">                         Type&lt;<span class="keyword">double</span>&gt;&gt;(),</span><br><span class="line">                  <span class="string">&quot;Type not found&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是<code>Contains</code>是如何实现的！显然它的作用是检查类型<code>T</code>是否包含在类型列表<code>Ts...</code>中。</p>
<p>首先是<code>template&lt;class T, class U&gt; std::is_same &#123;&#125;</code>，当<code>T</code>和<code>U</code>是相同类型时，<code>std::is_same&lt;T,U&gt;::value</code>为<code>true</code>，否则为<code>false</code>！这么表达其实也不准确，准确地说是，<strong>编译器生成了一堆这样的class</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">false_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">true_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">is_same</span>&lt;Foo, char&gt; :</span> <span class="keyword">public</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">is_same</span>&lt;Foo, Foo&gt; :</span> <span class="keyword">public</span> true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>单词disjunction的意思是<strong>析取、逻辑或</strong>，与它对应的是conjunction，<strong>合取、逻辑与</strong>。</p>
<p>这对模版是C++17引入的，这里只看<code>template&lt;class... B&gt; struct disjunction</code>（conjunction类似）。说白了<code>std::disjunction</code>就是执行逻辑OR运算：从左到右依次检查每个类型，若遇到<code>true_type</code>就立即返回它；若最终也没遇到则返回<code>false_type</code>。</p>
<p>显然：<code>Contains&lt;T, Ts...&gt;</code>就是<code>std::disjunction&lt;is_same&lt;T, T1&gt;, is_same&lt;T, T2&gt;, ..., is_same&lt;T, Tn&gt;&gt;</code>（假设<code>Ts=&#123;T1, T2, ..., Tn&#125;</code>）；其中有一个为true就代表包含！</p>
<h1 id="integer-sequence-2"><a href="#integer-sequence-2" class="headerlink" title="integer_sequence (2)"></a>integer_sequence (2)</h1><h2 id="编译时整数序列-2-1"><a href="#编译时整数序列-2-1" class="headerlink" title="编译时整数序列 (2.1)"></a>编译时整数序列 (2.1)</h2><p>模版std::integer_sequence是C++14标准库中引入的一个工具，用于在<strong>编译时</strong>生成整数序列。它位于<utility>头文件中，主要用于模板元编程和处理可变参数包（variadic templates）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T... idx&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integer_sequence</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">sizeof</span>...(idx); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>顾名思义，它是编译时生成的<strong>整数序列</strong>，非整数类型如<code>std::integer_sequence&lt;float, 1.0, 2.0, 3.0&gt;</code>会编译失败！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//编译失败：error: ‘float’ is not a valid type for a template non-type parameter</span></span><br><span class="line">  <span class="comment">//using FloatSeq = std::integer_sequence&lt;float, 1.0, 2.0, 3.0&gt;;</span></span><br><span class="line">  <span class="comment">//std::cout &lt;&lt; FloatSeq::size() &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印 &quot;c : 3&quot;</span></span><br><span class="line">  <span class="keyword">using</span> CharSeq = <span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">char</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;x&#x27;</span>&gt;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(CharSeq::value_type).name() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; CharSeq::size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印 &quot;s : 4&quot;</span></span><br><span class="line">  <span class="keyword">using</span> Int16Seq = <span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int16_t</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>&gt;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(Int16Seq::value_type).name() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; Int16Seq::size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印 &quot;i : 5&quot;</span></span><br><span class="line">  <span class="keyword">using</span> IntSeq = <span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(IntSeq::value_type).name() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; IntSeq::size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="生成integer-sequence的实例类-2-2"><a href="#生成integer-sequence的实例类-2-2" class="headerlink" title="生成integer_sequence的实例类 (2.2)"></a>生成integer_sequence的实例类 (2.2)</h2><p>生成实例类，更常见的使用方式是<code>make_integer_sequence</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印 &quot;l : 6&quot;</span></span><br><span class="line"><span class="keyword">using</span> LongSeq = <span class="built_in">std</span>::make_integer_sequence&lt;<span class="keyword">long</span> <span class="keyword">int</span>, <span class="number">6</span>&gt;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(LongSeq::value_type).name() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; LongSeq::size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>注意：<code>make_integer_sequence</code>生成的是一个类型，不是一个对象！这个类型是<code>integer_sequence&lt;long int, 0, 1, 2, 3, 4, 5&gt;</code>；如何生成的呢？一般编译器有builtin实现，假如没有的化，<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/integer_sequence">cppreference.com</a>给了一个实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">I</span>, <span class="title">T</span> <span class="title">N</span>, <span class="title">T</span>... <span class="title">integers</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">make_integer_sequence_helper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> make_integer_sequence_helper&lt;T, I + <span class="number">1</span>, N, integers..., I&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">N</span>, <span class="title">T</span>... <span class="title">integers</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">make_integer_sequence_helper</span>&lt;T, N, N, integers...&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">std</span>::integer_sequence&lt;T, integers...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">my_make_integer_sequence</span> = <span class="title">typename</span> <span class="title">make_integer_sequence_helper</span>&lt;T, 0, N&gt;:</span>:type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//打印 &quot;s : 3&quot;</span></span><br><span class="line">  <span class="keyword">using</span> ShortSeq = my_make_integer_sequence&lt;<span class="keyword">short</span>, <span class="number">3</span>&gt;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(ShortSeq::value_type).name() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; ShortSeq::size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这又是一个递归，和第1节有点类似，不过这次编译器面对的不是模版函数，而是模板类（其实差不多）：</p>
<ul>
<li><p><code>make_integer_sequence_helper</code>是主模版:</p>
<ul>
<li>类型参数：<code>T</code>，是一个整数类型(<code>char</code>, <code>short</code>, <code>int</code>等)；</li>
<li>后面是一个<code>T</code>类型的整数值序列：<code>I</code>, <code>N</code>, <code>integers...</code> (模版参数可以为类型，也可以为值)；</li>
<li>它有一个“类型成员”：<code>type</code>；这是递归的入口；</li>
</ul>
</li>
<li><p><code>make_integer_sequence_helper&lt;T, N, N, integers...&gt;</code>是模板偏特化：</p>
<ul>
<li>同样，类型参数：<code>T</code>，是一个整数类型(<code>char</code>, <code>short</code>, <code>int</code>等)；</li>
<li>但后面的整数值序列，<strong>要前2个相等才匹配这个偏特化</strong>！</li>
<li>它的”类型成员”：<code>type</code>就是递归出口了；</li>
</ul>
</li>
</ul>
<p>看一下编译器如何编译<code>my_make_integer_sequence&lt;short, 3&gt;</code>，它展开是<code>make_integer_sequence_helper&lt;short, 0, 3&gt;::type</code>；</p>
<ul>
<li>看<code>make_integer_sequence_helper&lt;short, 0, 3&gt;</code>，0和3不相等，匹配主模版：<ul>
<li><code>I=0</code>，<code>N=3</code>，<code>...integers=&#123;&#125;</code></li>
<li>那么它的<code>type</code>就是<code>make_integer_sequence_helper&lt;short, 1, 3, 0&gt;::type</code>；</li>
</ul>
</li>
<li>继续看<code>make_integer_sequence_helper&lt;short, 1, 3, 0&gt;</code>，1和3不相等，还是匹配主模板：<ul>
<li><code>I=1</code>，<code>N=3</code>，<code>...integers=&#123;0&#125;</code></li>
<li>那么它的<code>type</code>就是<code>make_integer_sequence_helper&lt;short, 2, 3, 0, 1&gt;::type</code>；</li>
</ul>
</li>
<li>继续看<code>make_integer_sequence_helper&lt;short, 2, 3, 0, 1&gt;</code>，2和3不相等，还是匹配主模板：<ul>
<li><code>I=2</code>，<code>N=3</code>，<code>...integers=&#123;0, 1&#125;</code></li>
<li>那么它的<code>type</code>就是<code>make_integer_sequence_helper&lt;short, 3, 3, 0, 1, 2&gt;::type</code>；</li>
</ul>
</li>
<li>最终<code>make_integer_sequence_helper&lt;short, 3, 3, 0, 1, 2&gt;</code>匹配偏特化，因为3和3相等：<ul>
<li><code>N=3</code>，<code>N=3</code>，<code>...integers=&#123;0, 1, 2&#125;</code></li>
<li>所以，它的<code>type</code>就是<code>std::integer_sequence&lt;short, 0, 1, 2&gt;</code></li>
</ul>
</li>
</ul>
<p>在这个过程中，编译器生成了4个中间类实例，假如它们分别是<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>，那么<code>A::type=B</code>，<code>B::type=C</code>，<code>C::type=D</code>；<code>D::type</code>才是最终我们要的<code>std::integer_sequence</code>!</p>
<h2 id="提取整数值序列-2-3"><a href="#提取整数值序列-2-3" class="headerlink" title="提取整数值序列 (2.3)"></a>提取整数值序列 (2.3)</h2><p>有个有意思的问题：<code>std::integer_sequence</code>实例类中只有<code>value_type</code>和<code>size()</code>静态函数，并没有那个整数值序列（没有”ShortSeq::seq”这样的东西）！那编译器为什么还要一顿递归呢？何不直接生成一个class，其<code>value_type=short</code>且<code>static size()</code>返回3呢？</p>
<p>其实也不是，<strong>编译器还是知道整数值序列的</strong>，因为编译器真的生成了不同的class实例；换句话说：<code>std::integer_sequence&lt;short, 1, 2, 3&gt;</code>和<code>std::integer_sequence&lt;short, 3, 2, 1&gt;</code>是不同的class实例，虽然它们的<code>value_type</code>都是<code>short</code>且<code>size()</code>都返回3；这可以通过如下辅助模版函数来证实：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_type_arg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//打印：void print_type_arg() [with T = std::integer_sequence&lt;short int, 1, 2, 3&gt;]</span></span><br><span class="line">  print_type_arg&lt;<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">short</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：void print_type_arg() [with T = std::integer_sequence&lt;short int, 3, 2, 1&gt;]</span></span><br><span class="line">  print_type_arg&lt;<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">short</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：void print_type_arg() [with T = std::integer_sequence&lt;int, 5, 8, 1, 1, 1&gt;]</span></span><br><span class="line">  <span class="keyword">using</span> IntSeq = <span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;;</span><br><span class="line">  print_type_arg&lt;IntSeq&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以利用编译器的推导能力来提取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqExtractor</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">short</span>... args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqExtractor</span>&lt;std::integer_sequence&lt;short, args...&gt;&gt; &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> Extractor = SeqExtractor&lt;<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">short</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">1</span>&gt;&gt;;</span><br><span class="line">  Extractor extractor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：</span></span><br><span class="line">  <span class="comment">//  static void SeqExtractor&lt;std::integer_sequence&lt;short int, args ...&gt; &gt;::foo() [with short int ...args = &#123;9, 1, 1&#125;]</span></span><br><span class="line">  <span class="comment">//  911</span></span><br><span class="line">  Extractor::foo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：</span></span><br><span class="line">  <span class="comment">//  void SeqExtractor&lt;std::integer_sequence&lt;short int, args ...&gt; &gt;::bar() [with short int ...args = &#123;9, 1, 1&#125;]</span></span><br><span class="line">  <span class="comment">//  911</span></span><br><span class="line">  extractor.bar();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>std::integer_sequence&lt;short, 9, 1, 1&gt;</code>去匹配偏特化，编译器推导出<code>...args=&#123;9, ,1, 1&#125;</code>；<strong>在<code>SeqExtractor</code>偏特化模版范围内，<code>args...</code>就是整数值序列包</strong>！</p>
<h2 id="index-sequence-2-4"><a href="#index-sequence-2-4" class="headerlink" title="index_sequence (2.4)"></a>index_sequence (2.4)</h2><p>其实不必多说，<code>std::index_sequence</code>就是<code>std::integer_sequence</code>的模版别名，把<code>T</code>固定为<code>size_t</code>；并且对应地，标准库也提供<code>std::make_integer_sequence</code>的别名<code>std::make_index_sequence</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_type_arg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> IndexSeq1 = <span class="built_in">std</span>::index_sequence&lt;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&gt;;</span><br><span class="line">  <span class="keyword">using</span> IndexSeq2 = <span class="built_in">std</span>::make_index_sequence&lt;<span class="number">4</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：void print_type_arg() [with T = std::integer_sequence&lt;long unsigned int, 2, 2, 2, 2&gt;]</span></span><br><span class="line">  print_type_arg&lt;IndexSeq1&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：void print_type_arg() [with T = std::integer_sequence&lt;long unsigned int, 0, 1, 2, 3&gt;]</span></span><br><span class="line">  print_type_arg&lt;IndexSeq2&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常量表达式-3"><a href="#常量表达式-3" class="headerlink" title="常量表达式 (3)"></a>常量表达式 (3)</h1><h2 id="常量表达式-3-1"><a href="#常量表达式-3-1" class="headerlink" title="常量表达式(3.1)"></a>常量表达式(3.1)</h2><p>常量表达式是<strong>编译期已知的不可变值</strong>，有5种：</p>
<ul>
<li><strong>字面量(Literals)</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span>          <span class="comment">// int 字面量</span></span><br><span class="line"><span class="number">3.14</span>        <span class="comment">// double 字面量</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>     <span class="comment">// 字符串字面量（类型为 const char[6]）</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>用constexpr声明的变量</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">10</span>;           <span class="comment">// 合法</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">double</span> b = a * <span class="number">2.5</span>;   <span class="comment">// 合法</span></span><br><span class="line">  <span class="comment">// constexpr int c = rand();    // error: call to non-‘constexpr’ function ‘int rand()’</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：10 25</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>只涉及常量表达式的运算</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> x = <span class="number">5</span> + <span class="number">3</span>;            <span class="comment">// 8</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> y = x &lt;&lt; <span class="number">2</span>;           <span class="comment">// 32</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> z = <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">8</span>;  <span class="comment">// 32（假设 int 为 4 字节）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：8 32 32</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>枚举值</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">  Red = <span class="number">1</span>,</span><br><span class="line">  Green = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> c = Red; <span class="comment">// 合法</span></span><br><span class="line">  <span class="comment">//打印：1</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>constexpr函数（当参数是常量表达式时）</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span>   sum1 = add(<span class="number">3</span>, <span class="number">4</span>);             <span class="comment">// 合法，sum1 = 7</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>       sum3 = add(rand(), rand());   <span class="comment">// 合法：但sum3不是常量表达式</span></span><br><span class="line">  <span class="comment">// constexpr int sum2 = add(rand(), rand());  // 非法！error: call to non-‘constexpr’ function ‘int rand()’</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印： 7 -1643747027</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然带有constexpr关键字，函数是否是常量表达式取决于上下文。可以这么理解：constexpr使一个函数可以出现在需要常量表达的地方，但不一定非要在那种情景下使用。见3.3节！</p>
<h2 id="常量表达式的应用场景-3-2"><a href="#常量表达式的应用场景-3-2" class="headerlink" title="常量表达式的应用场景 (3.2)"></a>常量表达式的应用场景 (3.2)</h2><ul>
<li>数组大小定义</li>
<li>模板参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> Size&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array&lt;<span class="number">5</span>&gt; arr;  <span class="comment">// 合法：5 是常量表达式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>静态断言（Static Assert）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) == <span class="number">4</span>, <span class="string">&quot;int must be 4 bytes&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>编译时计算</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> fact_5 = factorial(<span class="number">5</span>); <span class="comment">// 120（编译期计算）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//打印：120</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fact_5 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="constexpr-3-3"><a href="#constexpr-3-3" class="headerlink" title="constexpr (3.3)"></a>constexpr (3.3)</h2><p>第3.1节说过，<code>constexpr</code>关键字是声明<strong>常量表达式</strong>的方式之一！</p>
<ul>
<li><strong>constexpr变量</strong>：必须在编译期初始化，且initializer必须是常量表达式！</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> x = <span class="number">42</span>;             <span class="comment">// 编译期确定</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> y = x + <span class="number">1</span>;          <span class="comment">// 编译期确定</span></span><br><span class="line"><span class="comment">//constexpr int z = rand();       // 错误：rand() 不是常量表达式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>constexpr函数</strong>：可以在编译期调用，也可以在运行时调用，即<strong>取决于上下文</strong>：<ul>
<li>编译期调用：当参数是编译期常量且结果用于需要常量表达式的场景（如数组大小、模板参数）。</li>
<li>运行期调用：当参数是运行时变量或结果不用于常量表达式场景!</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">int</span> a = add(<span class="number">1</span>, <span class="number">2</span>);      <span class="comment">// 编译期求值</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">array</span>[a];             <span class="comment">// 合法！</span></span><br><span class="line">  <span class="keyword">int</span> b = add(<span class="number">3</span>, <span class="number">4</span>);                <span class="comment">// 可能编译期或运行期求值（取决于优化）</span></span><br><span class="line">  <span class="keyword">int</span> c = add(rand(), rand());      <span class="comment">// 运行期求值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：3 7 -1643747027</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如第3.1节所述，虽然带有constexpr关键字，函数是否是常量表达式取决于上下文。可以这么理解：constexpr使一个函数可以出现在需要常量表达的地方，但不一定非要在那种情景下使用。</p>
<h2 id="static-constexpr-vs-static-const-3-4"><a href="#static-constexpr-vs-static-const-3-4" class="headerlink" title="static constexpr vs static const (3.4)"></a>static constexpr vs static const (3.4)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">v</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">MyTemp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> T value1 = v;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span>     T value2 = v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> TempInst1 = MyTemp&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;TempInst1::value1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const int* p2 = &amp;TempInst1::value2; //导致链接错误：undefined reference to `MyTemp&lt;int, 3&gt;::value2&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印：3</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>static constexpr T value1 = v;</p>
<ul>
<li>编译期常量：constexpr强制要求变量在编译期初始化，且必须用常量表达式赋值。</li>
<li>隐式内联（C++17起）：允许T是任何字面类型，无需在类外定义即可直接使用（包括取地址），编译器自动处理存储。注意：C++17前，若T是类类型，仍需在类外定义！</li>
</ul>
</li>
</ul>
<ul>
<li><p>static const T value = v;</p>
<ul>
<li>运行时常量：const仅表示变量不可修改，初始化可以发生在运行时，也可以发生在编译期！</li>
<li>ODR依赖：若T是整型或枚举类型，允许类内初始化，其他类型（如double、类类型）必须在类外定义（即使有类内初始化）！若程序中使用其地址（ODR-used），必须在类外定义，否则可能引发链接错误。</li>
</ul>
</li>
</ul>
<p>ODR（One Definition Rule，单一定义规则）依赖：同一个实体（变量、函数、类等）在程序中必须有且仅有一个定义。违反 ODR 会导致未定义行为（UB），常见表现是编译或链接错误。</p>
<p>也就是说，当<code>T</code><strong>不为整型或枚举类型时</strong>，<code>value2</code>必须在类外定义！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTemp::value2 = ...</span><br></pre></td></tr></table></figure>

<p>而无论<code>T</code>是什么类型<code>value1</code>都不必在类外定义（C++17起）！</p>
<h2 id="constexpr-vs-const-3-5"><a href="#constexpr-vs-const-3-5" class="headerlink" title="constexpr vs. const (3.5)"></a>constexpr vs. const (3.5)</h2><table>
<thead>
<tr>
<th>特性</th>
<th>constexpr</th>
<th>const</th>
</tr>
</thead>
<tbody><tr>
<td>变量初始化时机</td>
<td>编译期，一定是常量表达式</td>
<td>编译期或运行时，不一定（依赖initializer）</td>
</tr>
<tr>
<td>函数调用时机</td>
<td>编译期或运行时(取决于上下文)</td>
<td>始终运行期调用（普通函数行为）</td>
</tr>
<tr>
<td>static成员变量</td>
<td>编译期常量，隐式内联（C++17起）</td>
<td>运行时常量，ODR依赖</td>
</tr>
<tr>
<td>适用场景</td>
<td>需要编译期确定的常量或逻辑</td>
<td>运行时常量</td>
</tr>
</tbody></table>
<h1 id="SFINAE原则-4"><a href="#SFINAE原则-4" class="headerlink" title="SFINAE原则 (4)"></a>SFINAE原则 (4)</h1><p>SFINAE（Substitution Failure Is Not An Error） 是 C++ 模板元编程中的核心原则，它允许在模板参数替换失败时不触发编译错误，而是将该模板候选从重载集中静默剔除。</p>
<h2 id="SFINAE的核心机制-4-1"><a href="#SFINAE的核心机制-4-1" class="headerlink" title="SFINAE的核心机制 (4.1)"></a>SFINAE的核心机制 (4.1)</h2><p>当编译器尝试实例化一个模板时，会经历以下步骤：</p>
<ul>
<li>替换（Substitution）：将模板参数代入模板声明，生成具体函数/类的签名。</li>
<li>检查有效性：验证代入后的模板代码是否合法（例如类型是否匹配、成员是否存在等）。</li>
<li>处理失败：<ul>
<li>如果替换失败（如访问不存在的成员、类型不兼容等），且失败发生在 直接替换过程 中（而非函数体内部），则根据 SFINAE 原则，忽略该候选模板，继续查找其他候选。</li>
<li>如果所有候选均失败，才会报错。</li>
</ul>
</li>
</ul>
<p>看下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅对整数类型有效</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_integral&lt;T&gt;::value, <span class="keyword">void</span>&gt;::type</span><br><span class="line">process(T value)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;处理整数：&quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅对浮点类型有效</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_floating_point&lt;T&gt;::value, <span class="keyword">void</span>&gt;::type</span><br><span class="line">process(T value)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;处理浮点：&quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印：处理整数：3</span></span><br><span class="line">  process(<span class="number">3</span>);          <span class="comment">// 匹配整数版本（浮点版本被 SFINAE 剔除）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印：处理浮点：3.14</span></span><br><span class="line">  process(<span class="number">3.14</span>);       <span class="comment">// 匹配浮点版本（整数版本被 SFINAE 剔除）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// process(&quot;hello&quot;); // 无匹配版本：no matching function for call to ‘process(const char [6])’</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一段合法代码，可编译运行。编译器在处理<code>process(42)</code>时，<strong>替换阶段</strong>会产生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">true</span>, <span class="keyword">void</span>&gt;::type</span><br><span class="line">process(T value) &#123; <span class="comment">/* 处理整数 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="literal">false</span>, <span class="keyword">void</span>&gt;::type</span><br><span class="line">process(T value) &#123; <span class="comment">/* 处理浮点数 */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>std::enable_if&lt;B, T&gt;</code>在<code>B=false</code>时，根本就没有<code>type</code>成员！也就是说，<strong>替换阶段</strong>就失败了。假如没有SFINAE机制，那么，就会导致编译失败，终止！</p>
<p>而有了SFINAE机制，编译器只会把这个<strong>失败的替换</strong>静默丢弃，不视为错误。</p>
<p>同理，编译器处理<code>process(3.14)</code>时，也会产生2个替换，并丢弃<strong>失败的替换</strong>。最终，两个正确的替换被保留下来。</p>
<p>所以，与编译错误的关键区别是：SFINAE失败仅影响重载选择，若最终无合法候选，才会触发编译错误。</p>
<h2 id="SFINAE的替代方案-4-2"><a href="#SFINAE的替代方案-4-2" class="headerlink" title="SFINAE的替代方案 (4.2)"></a>SFINAE的替代方案 (4.2)</h2><ul>
<li>if constexpr：在函数体内部实现编译期条件分支，避免多份重载（C++17起）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;处理整数: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (<span class="built_in">std</span>::is_floating_point_v&lt;T&gt;) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;处理浮点: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_integral_v&lt;T&gt; || <span class="built_in">std</span>::is_floating_point_v&lt;T&gt;, <span class="string">&quot;Unsupported type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 打印：处理整数: 3</span></span><br><span class="line">  process(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印：处理浮点: 3.14</span></span><br><span class="line">  process(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// process(&quot;hello&quot;);  // error: static assertion failed: Unsupported type</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Concepts：通过requires直接约束模板参数（C++20起）</li>
</ul>
<p>注：下面的代码Linux/gcc环境<code>g++ --std=c++2a</code>无法编译! 而Clang环境(macOS/Linux)下<code>clang++ --std=c++2a</code>可以编译运行!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">requires</span> <span class="built_in">std</span>::is_integral_v&lt;T&gt; || <span class="built_in">std</span>::is_floating_point_v&lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;处理整型或浮点: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 打印：处理整型或浮点: 3</span></span><br><span class="line">  process(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印：处理整型或浮点: 3.14</span></span><br><span class="line">  process(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// process(&quot;hello&quot;);  // error: no matching function for call to &#x27;process&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enable-if-4-3"><a href="#enable-if-4-3" class="headerlink" title="enable_if (4.3)"></a>enable_if (4.3)</h2><ul>
<li>基本定义</li>
</ul>
<p>当B为true：<code>enable_if_t&lt;B, T&gt;</code>等价于T；当B为false：<code>enable_if&lt;B, T&gt;</code> 无<code>type</code>成员，导致模板替换失败（SFINAE）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">enable_if</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">enable_if</span>&lt;true, T&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;  <span class="comment">// 当条件为 true 时定义 type 成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14 起提供的别名模板简化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">enable_if_t</span> = <span class="title">typename</span> <span class="title">enable_if</span>&lt;B, T&gt;:</span>:type;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心用途1：控制函数模板的重载</li>
</ul>
<p>比<code>if constexpr</code>可读性差，见4.2节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现1：针对整数类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_integral_v&lt;T&gt;, <span class="keyword">void</span>&gt;</span><br><span class="line">process(T value) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;处理整数: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现2：针对浮点类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_floating_point_v&lt;T&gt;, <span class="keyword">void</span>&gt;</span><br><span class="line">process(T value) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;处理浮点: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//打印：处理整数: 3</span></span><br><span class="line">  process(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印： 处理浮点: 3.14</span></span><br><span class="line">  process(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// process(&quot;hello&quot;); //error: no matching function for call to ‘process(const char [6])’</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>核心用途2：约束类模板参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当T是算术类型时可用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_arithmetic_v&lt;T&gt;&gt;&gt;</span><br><span class="line">struct MyContainer &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyContainer&lt;<span class="keyword">int</span>&gt; c1;             <span class="comment">// 编译通过</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// MyContainer&lt;std::string&gt; c2;  // error: template argument 2 is invalid</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，<code>typename = std::enable_if_t&lt;...&gt;</code>是<strong>未命名类型参数，即类型参数名被省略，因为不需要在类内使用</strong>。补全的话是:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Dummy = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_arithmetic_v&lt;T&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>其次，满足<code>is_arithmetic_v</code>时，得到的是<code>void</code>；其实是什么类型都是无所谓，例如改写成这样，是等效的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_arithmetic_v&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>因为这个<strong>未命名类型参数的作用是约束模版只对算术类型的T有效</strong>，若是非算术类型，<code>enable_it&lt;false&gt;::value</code>没有定义。</p>
<p>不过，上面这个代码可读性差（见4.2节），下面是使用<code>requires</code>重新实现：</p>
<p>注：下面的代码Linux/gcc环境<code>g++ --std=c++2a</code>无法编译! 而Clang环境(macOS/Linux)下<code>clang++ --std=c++2a</code>可以编译运行!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅当T是算术类型时可用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">requires</span> <span class="built_in">std</span>::is_arithmetic_v&lt;T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyContainer</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyContainer&lt;<span class="keyword">int</span>&gt; c1;             <span class="comment">// 编译通过</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// MyContainer&lt;std::string&gt; c2;  // error: constraints not satisfied for class template &#x27;MyContainer&#x27; [with T = std::basic_string&lt;char&gt;]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常见错误：条件重叠导致歧义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; func(T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, void&gt; func(T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 条件重叠（整数也是算术类型）</span></span><br><span class="line">  <span class="comment">// func(3); //error: call of overloaded ‘func(int)’ is ambiguous</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div class="reward-container">
  <div>写的不错，有赏！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Yuanguo Huo 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Yuanguo Huo 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/template/" rel="tag"># template</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/06/07/cpp17-template-specialization/" rel="prev" title="C++的模版特化">
      <i class="fa fa-chevron-left"></i> C++的模版特化
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/09/12/tcpdump/" rel="next" title="tcpdump的使用">
      tcpdump的使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          本站概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8BT-1"><span class="nav-number">1.</span> <span class="nav-text">查找一个类型T (1)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E6%AD%A5%E5%B0%9D%E8%AF%95-1-1"><span class="nav-number">1.1.</span> <span class="nav-text">初步尝试 (1.1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98-1-2"><span class="nav-number">1.2.</span> <span class="nav-text">变量值的问题 (1.2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%96%84-1-3"><span class="nav-number">1.3.</span> <span class="nav-text">完善 (1.3)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#integer-sequence-2"><span class="nav-number">2.</span> <span class="nav-text">integer_sequence (2)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97-2-1"><span class="nav-number">2.1.</span> <span class="nav-text">编译时整数序列 (2.1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90integer-sequence%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%B1%BB-2-2"><span class="nav-number">2.2.</span> <span class="nav-text">生成integer_sequence的实例类 (2.2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E6%95%B4%E6%95%B0%E5%80%BC%E5%BA%8F%E5%88%97-2-3"><span class="nav-number">2.3.</span> <span class="nav-text">提取整数值序列 (2.3)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#index-sequence-2-4"><span class="nav-number">2.4.</span> <span class="nav-text">index_sequence (2.4)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F-3"><span class="nav-number">3.</span> <span class="nav-text">常量表达式 (3)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F-3-1"><span class="nav-number">3.1.</span> <span class="nav-text">常量表达式(3.1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3-2"><span class="nav-number">3.2.</span> <span class="nav-text">常量表达式的应用场景 (3.2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr-3-3"><span class="nav-number">3.3.</span> <span class="nav-text">constexpr (3.3)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-constexpr-vs-static-const-3-4"><span class="nav-number">3.4.</span> <span class="nav-text">static constexpr vs static const (3.4)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr-vs-const-3-5"><span class="nav-number">3.5.</span> <span class="nav-text">constexpr vs. const (3.5)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SFINAE%E5%8E%9F%E5%88%99-4"><span class="nav-number">4.</span> <span class="nav-text">SFINAE原则 (4)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SFINAE%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6-4-1"><span class="nav-number">4.1.</span> <span class="nav-text">SFINAE的核心机制 (4.1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SFINAE%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88-4-2"><span class="nav-number">4.2.</span> <span class="nav-text">SFINAE的替代方案 (4.2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#enable-if-4-3"><span class="nav-number">4.3.</span> <span class="nav-text">enable_if (4.3)</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuanguo Huo"
      src="/images/me.gif">
  <p class="site-author-name" itemprop="name">Yuanguo Huo</p>
  <div class="site-description" itemprop="description">A little better than yesterday</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanguohuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanguohuo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanguo.h001@gmail.com" title="E-Mail → mailto:yuanguo.h001@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanguo Huo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"sKs2IrqwziD8hQqWqhcBdmxB-gzGzoHsz","app_key":"j2NAkBzz8pzcwkRlYdi87QEY","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'sKs2IrqwziD8hQqWqhcBdmxB-gzGzoHsz',
      appKey     : 'j2NAkBzz8pzcwkRlYdi87QEY',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

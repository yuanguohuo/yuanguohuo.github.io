<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Linux tracing中有3层：front-end, tracer(即tracing framework)和event-source. Tracepoint属于event-source，是一种kernel static tracing事件源。本文介绍tracepoint的实现以及使用方式，特别是如何被ftrace使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Tracepoint">
<meta property="og:url" content="http://yoursite.com/2023/07/18/linux-tracing-tracepoint/index.html">
<meta property="og:site_name" content="Yuanguo&#39;s Blog">
<meta property="og:description" content="Linux tracing中有3层：front-end, tracer(即tracing framework)和event-source. Tracepoint属于event-source，是一种kernel static tracing事件源。本文介绍tracepoint的实现以及使用方式，特别是如何被ftrace使用。">
<meta property="og:locale">
<meta property="article:published_time" content="2023-07-18T18:30:32.000Z">
<meta property="article:modified_time" content="2025-07-10T09:32:33.520Z">
<meta property="article:author" content="Yuanguo Huo">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="tracing">
<meta property="article:tag" content="event-source">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2023/07/18/linux-tracing-tracepoint/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Linux Tracepoint | Yuanguo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yuanguo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/07/18/linux-tracing-tracepoint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.gif">
      <meta itemprop="name" content="Yuanguo Huo">
      <meta itemprop="description" content="A little better than yesterday">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanguo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux Tracepoint
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="Created: 2023-07-18 18:30:32" itemprop="dateCreated datePublished" datetime="2023-07-18T18:30:32+00:00">2023-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="Modified: 2025-07-10 09:32:33" itemprop="dateModified" datetime="2025-07-10T09:32:33+00:00">2025-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">所属分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tracing/" itemprop="url" rel="index"><span itemprop="name">tracing</span></a>
                </span>
            </span>

          
            <span id="/2023/07/18/linux-tracing-tracepoint/" class="post-meta-item leancloud_visitors" data-flag-title="Linux Tracepoint" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/18/linux-tracing-tracepoint/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/18/linux-tracing-tracepoint/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Linux tracing中有3层：front-end, tracer(即tracing framework)和event-source. Tracepoint属于event-source，是一种kernel static tracing事件源。本文介绍tracepoint的实现以及使用方式，特别是如何被ftrace使用。</p>
<a id="more"></a>

<h1 id="概述-1"><a href="#概述-1" class="headerlink" title="概述 (1)"></a>概述 (1)</h1><p>广义的tracepoint指静态tracepoint(本文内容)和动态tracepoint(包括kprobe和uprobe)。狭义的tracepoint就是静态tracepoint；它在内核代码中就叫tracepoint，实例由结构体<code>struct tracepoint __tracepoint_##name</code>表示(其中<code>##name</code>是<code>##subsys_##eventname</code>)；hook函数是<code>trace_##name()</code>，即<code>trace_##subsys_##eventname()</code>。静态的意思是，预先在内核代码中调用hook函数。所以它只能trace这些编译到内核中的hook点。下文的tracepoint都是指狭义的静态tracepoint.</p>
<p>内核的基础框架部分包含一套tracepoint机制，用于何创建与使用tracepoint实例。Subsystem及kernel-module开发者使用这套机制创建tracepoint实例<code>__tracepoint_##subsys_##eventname</code>并在重要的内核代码路径上调用<code>trace_##subsys_##eventname()</code>函数，即放置hook；hook函数用于调用probe函数(也叫callback函数，在本文中这两个词是等价的)；probe函数是使用者在运行时提供的。也就是说，hook是静态的，probe是动态的。Tracepoint实例可以是<code>on</code>状态(hook关联着一个或多个probe)，也可以是<code>off</code>状态(hook不与任何probe关联)。处于<code>off</code>状态的tracepoint不起作用，除了增加一点时间开销(checking a condition for a branch)和一点空间开销(adding a few bytes for the function call at the end of the instrumented function and adds a data structure in a separate section)；而当tracepoint在<code>on</code>状态时，每次执行到hook时，probe函数就被调用一次。</p>
<p>显然，创建tracepoint与放置hook是内核开发者(subsys及module开发者)的事，使用tracepoint(实现probe并与hook关联)是系统维护者，或者任何要学习、定位系统bug、追踪系统性能的人员的事。</p>
<h1 id="创建tracepoint-2"><a href="#创建tracepoint-2" class="headerlink" title="创建tracepoint (2)"></a>创建tracepoint (2)</h1><p>严格来说，tracepoint是由<code>DECLARE_TRACE/DEFINE_TRACE</code>创建的。但目前内核已不直接使用它来创建tracepoint，而是通过下文介绍的<code>TRACE_EVENT</code>宏。然而<code>DECLARE_TRACE/DEFINE_TRACE</code>是<code>TRACE_EVENT</code>的基础：<code>TRACE_EVENT</code>展开后包含<code>DECLARE_TRACE/DEFINE_TRACE</code>。<code>DECLARE_TRACE/DEFINE_TRACE</code>能够完整的创建tracepoint；<code>TRACE_EVENT</code>是在创建的tracepoint之后，为使用它提供一些便利。</p>
<p>创建tracepoint分2步：declare和define，分别有<code>DECLARE_TRACE</code>和<code>DEFINE_TRACE</code>完成。内核开发者这样使用它们(例如开发foo subsystem，创建bar tracepoint)：</p>
<ul>
<li>declare tracepoint</li>
</ul>
<p>在header文件<code>include/trace/events/foo.h</code>中使用<code>DECLARE_TRACE</code>声明tracepoint:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> TRACE_SYSTEM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRACE_SYSTEM subsys</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_TRACE_SUBSYS_H) || defined(TRACE_HEADER_MULTI_READ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TRACE_SUBSYS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tracepoint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_TRACE(foo_bar,</span><br><span class="line">        TP_PROTO(<span class="keyword">int</span> firstarg, struct task_struct *p),</span><br><span class="line">        TP_ARGS(firstarg, p));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _TRACE_SUBSYS_H */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This part must be outside protection */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;trace/define_trace.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>宏<code>DECLARE_TRACE</code>定义在<code>include/linux/tracepoint.h</code>中，以linux-5.10.161为例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_TRACE(name, proto, args)                                \</span></span><br><span class="line">        __DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),              \</span><br><span class="line">                        cpu_online(raw_smp_processor_id()),             \</span><br><span class="line">                        PARAMS(<span class="keyword">void</span> *__data, proto),                    \</span><br><span class="line">                        PARAMS(__data, args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DECLARE_TRACE(name, proto, args, cond, data_proto, data_args) \</span></span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">int</span> __traceiter_#<span class="meta">#name(data_proto);                      \</span></span><br><span class="line">        DECLARE_STATIC_CALL(tp_func_##name, __traceiter_##name);        \</span><br><span class="line">        <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">tracepoint</span> __<span class="title">tracepoint_</span>##<span class="title">name</span>;</span>                   \</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> trace_#<span class="meta">#name(proto)                          \</span></span><br><span class="line">        &#123;                                                               \</span><br><span class="line">                <span class="keyword">if</span> (static_key_false(&amp;__tracepoint_##name.key))         \</span><br><span class="line">                        __DO_TRACE(name,                                \</span><br><span class="line">                                TP_PROTO(data_proto),                   \</span><br><span class="line">                                TP_ARGS(data_args),                     \</span><br><span class="line">                                TP_CONDITION(cond), <span class="number">0</span>);                 \</span><br><span class="line">                <span class="keyword">if</span> (IS_ENABLED(CONFIG_LOCKDEP) &amp;&amp; (cond)) &#123;             \</span><br><span class="line">                        rcu_read_lock_sched_notrace();                  \</span><br><span class="line">                        rcu_dereference_sched(__tracepoint_##name.funcs);\</span><br><span class="line">                        rcu_read_unlock_sched_notrace();                \</span><br><span class="line">                &#125;                                                       \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        __DECLARE_TRACE_RCU(name, PARAMS(proto), PARAMS(args),          \</span><br><span class="line">                PARAMS(cond), PARAMS(data_proto), PARAMS(data_args))    \</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span>                                               \</span><br><span class="line">        register_trace_#<span class="meta">#name(void (*probe)(data_proto), void *data)    \</span></span><br><span class="line">        &#123;                                                               \</span><br><span class="line">                <span class="keyword">return</span> tracepoint_probe_register(&amp;__tracepoint_##name,  \</span><br><span class="line">                                                (<span class="keyword">void</span> *)probe, data);   \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span>                                               \</span><br><span class="line">        register_trace_prio_#<span class="meta">#name(void (*probe)(data_proto), void *data,\</span></span><br><span class="line">                                   <span class="keyword">int</span> prio)                            \</span><br><span class="line">        &#123;                                                               \</span><br><span class="line">                <span class="keyword">return</span> tracepoint_probe_register_prio(&amp;__tracepoint_##name, \</span><br><span class="line">                                              (<span class="keyword">void</span> *)probe, data, prio); \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span>                                               \</span><br><span class="line">        unregister_trace_#<span class="meta">#name(void (*probe)(data_proto), void *data)  \</span></span><br><span class="line">        &#123;                                                               \</span><br><span class="line">                <span class="keyword">return</span> tracepoint_probe_unregister(&amp;__tracepoint_##name,\</span><br><span class="line">                                                (<span class="keyword">void</span> *)probe, data);   \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span>                                              \</span><br><span class="line">        check_trace_callback_type_#<span class="meta">#name(void (*cb)(data_proto))        \</span></span><br><span class="line">        &#123;                                                               \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span>                                              \</span><br><span class="line">        trace_#<span class="meta">#name##_enabled(void)                                    \</span></span><br><span class="line">        &#123;                                                               \</span><br><span class="line">                <span class="keyword">return</span> static_key_false(&amp;__tracepoint_##name.key);      \</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可见，这里定义了一些函数：</p>
<ul>
<li><code>trace_foo_bar()</code>: 放置hook；</li>
<li><code>register_trace_foo_bar()/unregister_trace_foo_bar()</code>: 关联/解绑probe;</li>
<li><code>trace_foo_bar_enabled()</code>: tracepoint是否开启；</li>
</ul>
<p>除此之外，还声明了一个<code>extern struct tracepoint</code>类型的结构体<code>__tracepoint_foo_bar</code>(注意带有<code>extern</code>，只声明，没有定义). 类型<code>struct tracepoint</code>定义在<code>include/linux/tracepoint-defs.h</code>(linux-5.10.161):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tracepoint</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;               <span class="comment">/* Tracepoint name */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> <span class="title">key</span>;</span>          <span class="comment">/*用于确定是否enabled*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">static_call_key</span> *<span class="title">static_call_key</span>;</span></span><br><span class="line">        <span class="keyword">void</span> *static_call_tramp;</span><br><span class="line">        <span class="keyword">void</span> *iterator;</span><br><span class="line">        <span class="keyword">int</span> (*regfunc)(<span class="keyword">void</span>);                <span class="comment">/*在add probe之前调用*/</span></span><br><span class="line">        <span class="keyword">void</span> (*unregfunc)(<span class="keyword">void</span>);             <span class="comment">/*在remove probe之后调用?*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tracepoint_func</span> __<span class="title">rcu</span> *<span class="title">funcs</span>;</span> <span class="comment">/*probe函数, 允许有多个*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>define tracepoint</li>
</ul>
<p>在C文件<code>foo/xx.c</code>中使用<code>DEFINE_TRACE</code>define tracepoint:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;trace&#x2F;events&#x2F;subsys.h&gt;</span><br><span class="line"></span><br><span class="line">#define CREATE_TRACE_POINTS</span><br><span class="line">DEFINE_TRACE(subsys_eventname);</span><br></pre></td></tr></table></figure>

<p>声明中带有<code>extern</code>，所以没有分配<code>struct tracepoint __tracepoint_foo_bar</code>，这里才真正分配这个变量，它被存储在<code>__tracepoints</code> section中。以linux-5.10.161为例，<code>DEFINE_TRACE</code>展开为(在<code>include/linux/tracepoint.h</code>中)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_TRACE(name, proto, args)                                 \</span></span><br><span class="line">        DEFINE_TRACE_FN(name, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PARAMS(proto), PARAMS(args));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_TRACE_FN(_name, _reg, _unreg, proto, args)               \</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> __tpstrtab_##_name[]                          \</span><br><span class="line">        __section(<span class="string">&quot;__tracepoints_strings&quot;</span>) = #_name;                    \</span><br><span class="line">        <span class="function"><span class="keyword">extern</span> struct static_call_key <span class="title">STATIC_CALL_KEY</span><span class="params">(tp_func_##_name)</span></span>; \</span><br><span class="line">        <span class="keyword">int</span> __traceiter_##_name(<span class="keyword">void</span> *__data, proto);                   \</span><br><span class="line">                                                                        \</span><br><span class="line">        <span class="comment">/*分配__tracepoint_foo_bar，在__tracepoints段*/</span>                 \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tracepoint</span> __<span class="title">tracepoint_</span>##_<span class="title">name</span>  __<span class="title">used</span>                  \</span></span><br><span class="line"><span class="class">        __<span class="title">section</span>(&quot;__<span class="title">tracepoints</span>&quot;) = &#123;</span>                                  \</span><br><span class="line">                .name = __tpstrtab_##_name,                             \</span><br><span class="line">                .key = STATIC_KEY_INIT_FALSE,                           \</span><br><span class="line">                .static_call_key = &amp;STATIC_CALL_KEY(tp_func_##_name),   \</span><br><span class="line">                .static_call_tramp = STATIC_CALL_TRAMP_ADDR(tp_func_##_name), \</span><br><span class="line">                .iterator = &amp;__traceiter_##_name,                       \</span><br><span class="line">                .regfunc = _reg,                                        \</span><br><span class="line">                .unregfunc = _unreg,                                    \</span><br><span class="line">                .funcs = <span class="literal">NULL</span> &#125;;                                        \</span><br><span class="line">                                                                        \</span><br><span class="line">        <span class="comment">/*调用trace_foo_bar，最终会调此函数：逐个调用funcs中的probe*/</span>   \</span><br><span class="line">        __TRACEPOINT_ENTRY(_name);                                      \</span><br><span class="line">        <span class="keyword">int</span> __traceiter_##_name(<span class="keyword">void</span> *__data, proto)                    \</span><br><span class="line">        &#123;                                                               \</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">tracepoint_func</span> *<span class="title">it_func_ptr</span>;</span>                    \</span><br><span class="line">                <span class="keyword">void</span> *it_func;                                          \</span><br><span class="line">                                                                        \</span><br><span class="line">                it_func_ptr =                                           \</span><br><span class="line">                        rcu_dereference_raw((&amp;__tracepoint_##_name)-&gt;funcs); \</span><br><span class="line">                <span class="keyword">if</span> (it_func_ptr) &#123;                                      \</span><br><span class="line">                        <span class="keyword">do</span> &#123;                                            \</span><br><span class="line">                                it_func = (it_func_ptr)-&gt;func;          \</span><br><span class="line">                                __data = (it_func_ptr)-&gt;data;           \</span><br><span class="line">                                ((<span class="keyword">void</span>(*)(<span class="keyword">void</span> *, proto))(it_func))(__data, args); \</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((++it_func_ptr)-&gt;func);                \</span><br><span class="line">                &#125;                                                       \</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;                                               \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        DEFINE_STATIC_CALL(tp_func_##_name, __traceiter_##_name);</span><br></pre></td></tr></table></figure>

<ul>
<li>放置hook</li>
</ul>
<p>在需要放置tracepoint的地方，例如<code>foo/yy.c</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void some_kernel_func(void)</span><br><span class="line">&#123;</span><br><span class="line">        ...</span><br><span class="line">        trace_foo_bar(arg, task);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前所述，最后会逐个调用probe；使用<code>register_trace_foo_bar()</code>关联probe，使用<code>unregister_trace_foo_bar()</code>解除关联的probe。</p>
<p>这种方式创建了一个叫<code>bar</code>的tracepoint，隶属于<code>foo</code> subsystem；要使用它，使用者必须提供probe，内核开发者没有提供任何默认probe；要想注册probe，需要开发一个内核模块，在模块中实现probe，并通过<code>register_trace_foo_bar/unregister_trace_foo_bar</code>关联或解除关联。所以，不方便使用。我看了几个版本，3.19.8，5.10.161以及6.4.9，都极少直接使用<code>DECLARE_TRACE/DEFINE_TRACE</code>：只有<code>sched.h</code>使用它创建了几个tracepoint，还是”for testing and debugging purposes”。</p>
<h1 id="作为ftrace的event-source-3"><a href="#作为ftrace的event-source-3" class="headerlink" title="作为ftrace的event-source (3)"></a>作为ftrace的event-source (3)</h1><h2 id="TRACE-EVENT的结构-3-1"><a href="#TRACE-EVENT的结构-3-1" class="headerlink" title="TRACE_EVENT的结构 (3.1)"></a><code>TRACE_EVENT</code>的结构 (3.1)</h2><p>当前内核版本中，tracepoint自动作为ftrace的一个event-source，所以也叫<strong>trace event</strong>。注意，这不意味着tracepoint和ftrace绑定或者耦合了：ftrace只是可以使用它的tracer之一，其它tracer，例如perf, LTTng, SystemTap都可以使用tracepoint；tracepoint对使用它的tracer是无感知的。</p>
<p>鉴于自动作为ftrace的event-source，当前内核提供了一个新的宏来创建tracepoint，它就是<code>TRACE_EVENT</code>，强调它是一个<strong>event</strong>。可以这么理解，为了方便使用，<code>TRACE_EVENT</code>在创建tracepoint的同时，还自动为其提供一个probe实现：这个probe可以直接被ftrace使用(ftrace属于tracer)，在第3.3节中将看到这个probe.</p>
<p><code>TRACE_EVENT</code>的目标是：</p>
<ul>
<li>Target-A: It must create a tracepoint (指的是hook) that can be placed in the kernel code.</li>
<li>Target-B: It must create a callback(即probe) function that can be hooked to this tracepoint.</li>
<li>Target-C: The callback(probe) function must be able to record the data passed to it into the tracer ring buffer in the fastest way possible. 即callback/probe函数必须能够把它的入参记录到tracer ring buffer中去(tracer就是ftrace，所以就是记录到ftrace ring buffer中)。</li>
<li>Target-D: It must create a function that can parse the data recorded to the ring buffer and translate it to a human readable format that the tracer can display to a user.</li>
</ul>
<p>为了达到这些目标，<code>TRACE_EVENT</code>宏被设计成六部分，对应它的六个参数<code>TRACE_EVENT(name, proto, args, struct, assign, print)</code>:</p>
<ul>
<li>Param-1 (<code>name</code>): the name of the tracepoint to be created.</li>
<li>Param-2 (<code>prototype</code>): the prototype for the tracepoint callback(probe)；</li>
<li>Param-3 (<code>args</code>): the arguments that match the prototype.</li>
<li>Param-4 (<code>struct</code>): the structure that a tracer could use (but is not required to) to store the data passed into the tracepoint；Target-C说，callback/probe函数必须能够把它的入参记录到ftrace ring buffer中；这个结构体就是在ftrace ring buffer中的entry的类型；注意，这里定义的只是一些字段，不是整个结构体，<code>TRACE_EVENT</code>会把它展开到一个结构体中(结构体还有其他字段)；一个真实的例子是<code>struct trace_event_raw_sched_switch</code>(见第3.3节，第3次展开)；</li>
<li>Param-5 (<code>assign</code>): the C-like way to assign the data to the structure. 实现Target-C：callback/probe在ftrace ring buffer中创建一个entry(类型如上<code>struct</code>)，然后调用<code>assign</code>给entry赋值。所以<code>assign</code>不是probe函数，也应该是probe函数的组成部分(果然：见第3.3节，第8次展开)。</li>
<li>Param-6 (<code>print</code>): the way to output the structure in human readable ASCII format. 实现Target-D: 把entry(类型如上<code>struct</code>)转化成可读形式，写入用户态output buffer(见第3.3节，第5次展开)。</li>
</ul>
<h2 id="例子-3-2"><a href="#例子-3-2" class="headerlink" title="例子 (3.2)"></a>例子 (3.2)</h2><p>从本节开始不再以<code>foo_bar</code>为例，而是使用一个真实的例子<code>sched_switch</code>，这样更有体感。它的定义在<code>include/trace/events/sched.h</code>中(linux-5.10.161):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">TRACE_EVENT(sched_switch,</span><br><span class="line"></span><br><span class="line">        TP_PROTO(<span class="keyword">bool</span> preempt,</span><br><span class="line">                 struct task_struct *prev,</span><br><span class="line">                 struct task_struct *next),</span><br><span class="line"></span><br><span class="line">        TP_ARGS(preempt, prev, next),</span><br><span class="line"></span><br><span class="line">        TP_STRUCT__entry(</span><br><span class="line">                __array(        <span class="keyword">char</span>,   prev_comm,      TASK_COMM_LEN   )</span><br><span class="line">                __field(        <span class="keyword">pid_t</span>,  prev_pid                        )</span><br><span class="line">                __field(        <span class="keyword">int</span>,    prev_prio                       )</span><br><span class="line">                __field(        <span class="keyword">long</span>,   prev_state                      )</span><br><span class="line">                __array(        <span class="keyword">char</span>,   next_comm,      TASK_COMM_LEN   )</span><br><span class="line">                __field(        <span class="keyword">pid_t</span>,  next_pid                        )</span><br><span class="line">                __field(        <span class="keyword">int</span>,    next_prio                       )</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        TP_fast_assign(</span><br><span class="line">                <span class="built_in">memcpy</span>(__entry-&gt;next_comm, next-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">                __entry-&gt;prev_pid       = prev-&gt;pid;</span><br><span class="line">                __entry-&gt;prev_prio      = prev-&gt;prio;</span><br><span class="line">                __entry-&gt;prev_state     = __trace_sched_switch_state(preempt, prev);</span><br><span class="line">                <span class="built_in">memcpy</span>(__entry-&gt;prev_comm, prev-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">                __entry-&gt;next_pid       = next-&gt;pid;</span><br><span class="line">                __entry-&gt;next_prio      = next-&gt;prio;</span><br><span class="line">                <span class="comment">/* XXX SCHED_DEADLINE */</span></span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        TP_printk(<span class="string">&quot;prev_comm=%s prev_pid=%d prev_prio=%d prev_state=%s%s ==&gt; next_comm=%s next_pid=%d next_prio=%d&quot;</span>,</span><br><span class="line">                __entry-&gt;prev_comm, __entry-&gt;prev_pid, __entry-&gt;prev_prio,</span><br><span class="line"></span><br><span class="line">                (__entry-&gt;prev_state &amp; (TASK_REPORT_MAX - <span class="number">1</span>)) ?</span><br><span class="line">                  __print_flags(__entry-&gt;prev_state &amp; (TASK_REPORT_MAX - <span class="number">1</span>), <span class="string">&quot;|&quot;</span>,</span><br><span class="line">                                &#123; TASK_INTERRUPTIBLE, <span class="string">&quot;S&quot;</span> &#125;,</span><br><span class="line">                                &#123; TASK_UNINTERRUPTIBLE, <span class="string">&quot;D&quot;</span> &#125;,</span><br><span class="line">                                &#123; __TASK_STOPPED, <span class="string">&quot;T&quot;</span> &#125;,</span><br><span class="line">                                &#123; __TASK_TRACED, <span class="string">&quot;t&quot;</span> &#125;,</span><br><span class="line">                                &#123; EXIT_DEAD, <span class="string">&quot;X&quot;</span> &#125;,</span><br><span class="line">                                &#123; EXIT_ZOMBIE, <span class="string">&quot;Z&quot;</span> &#125;,</span><br><span class="line">                                &#123; TASK_PARKED, <span class="string">&quot;P&quot;</span> &#125;,</span><br><span class="line">                                &#123; TASK_DEAD, <span class="string">&quot;I&quot;</span> &#125;) :</span><br><span class="line">                  <span class="string">&quot;R&quot;</span>,</span><br><span class="line"></span><br><span class="line">                __entry-&gt;prev_state &amp; TASK_REPORT_MAX ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                __entry-&gt;next_comm, __entry-&gt;next_pid, __entry-&gt;next_prio)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先演练一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/<span class="built_in">sched</span>/sched_switch/<span class="built_in">enable</span></span><br><span class="line">$ head -n 20 /sys/kernel/debug/tracing/trace</span><br><span class="line"></span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># entries-in-buffer/entries-written: 18375/18375   #P:16</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                                _-----=&gt; irqs-off</span></span><br><span class="line"><span class="comment">#                               / _----=&gt; need-resched</span></span><br><span class="line"><span class="comment">#                              | / _---=&gt; hardirq/softirq</span></span><br><span class="line"><span class="comment">#                              || / _--=&gt; preempt-depth</span></span><br><span class="line"><span class="comment">#                              ||| /     delay</span></span><br><span class="line"><span class="comment">#           TASK-PID     CPU#  ||||   TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |         |   ||||      |         |</span></span><br><span class="line">          &lt;idle&gt;-0       [012] d... 197376.159374: sched_switch: prev_comm=swapper/12 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=kworker/u32:1 next_pid=21084 next_prio=120</span><br><span class="line">   kworker/u32:1-21084   [012] d... 197376.159382: sched_switch: prev_comm=kworker/u32:1 prev_pid=21084 prev_prio=120 prev_state=I ==&gt; next_comm=swapper/12 next_pid=0 next_prio=120</span><br><span class="line">          &lt;idle&gt;-0       [008] d... 197376.159387: sched_switch: prev_comm=swapper/8 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=sshd next_pid=21056 next_prio=120</span><br><span class="line">            sshd-21056   [008] d... 197376.159409: sched_switch: prev_comm=sshd prev_pid=21056 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/8 next_pid=0 next_prio=120</span><br><span class="line">          &lt;idle&gt;-0       [012] d... 197376.159480: sched_switch: prev_comm=swapper/12 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=kworker/u32:1 next_pid=21084 next_prio=120</span><br><span class="line">            bash-21058   [010] d... 197376.159481: sched_switch: prev_comm=bash prev_pid=21058 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/10 next_pid=0 next_prio=120</span><br><span class="line">   kworker/u32:1-21084   [012] d... 197376.159485: sched_switch: prev_comm=kworker/u32:1 prev_pid=21084 prev_prio=120 prev_state=I ==&gt; next_comm=swapper/12 next_pid=0 next_prio=120</span><br><span class="line">          &lt;idle&gt;-0       [008] d... 197376.159491: sched_switch: prev_comm=swapper/8 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=sshd next_pid=21056 next_prio=120</span><br><span class="line">            sshd-21056   [008] d... 197376.159506: sched_switch: prev_comm=sshd prev_pid=21056 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/8 next_pid=0 next_prio=120</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>猜测：</p>
<ul>
<li>hook函数调用probe函数，它们的prototype一样；</li>
<li>probe函数在ftrace ring buffer中构造一个entry，类型是<code>TP_STRUCT__entry</code>；</li>
<li>probe函数调用<code>assign</code>给entry赋值；</li>
<li>ftrace调用<code>TP_printk</code>显示trace到的信息；</li>
</ul>
<p>通过后文可知：</p>
<ul>
<li>hook函数还是<code>__DECLARE_TRACE</code>中的<code>trace_##name</code>展开的，所以hook的prototype是：<code>trace_sched_switch(bool preempt, struct task_struct *prev, struct task_struct *next);</code> probe只比hook多了一个参数；</li>
<li>为什么还要<code>TP_ARGS(preempt, prev, next)</code>呢？因为有了它hook调用probe就方便了：<code>probe(..., preempt, prev, next);</code></li>
<li><code>TP_STRUCT__entry</code>里定义了一些struct的字段，不是完整的struct；它们将多次被展开到不同的struct里。它们最终展开成啥样，取决于<code>__array</code>, <code>__field</code>等宏如何实现；在<code>struct trace_event_raw_sched_switch</code>中，展开的结果就是字面的样子，这个struct也就是entry的结构。</li>
<li>另外，<code>sched_switch</code>例子也比较简单，没有<code>__dynamic_array</code>类型的字段；dynamic字段size不确定，所以它们在结构体中的offset也需要动态处理(本文不考虑)；</li>
</ul>
<p>第3.3节将回顾这个猜测，做更清晰的解释。</p>
<h2 id="TRACE-EVENT的实现-3-3"><a href="#TRACE-EVENT的实现-3-3" class="headerlink" title="TRACE_EVENT的实现 (3.3)"></a><code>TRACE_EVENT</code>的实现 (3.3)</h2><p>宏<code>TRACE_EVENT</code>一共被展开9次。</p>
<h3 id="第1次展开-3-3-1"><a href="#第1次展开-3-3-1" class="headerlink" title="第1次展开 (3.3.1)"></a>第1次展开 (3.3.1)</h3><p>在<code>include/linux/tracepoint.h</code>中(linux-5.10.161):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRACE_EVENT(name, proto, args, struct, assign, print)   \</span></span><br><span class="line">        DECLARE_TRACE(name, PARAMS(proto), PARAMS(args))</span><br></pre></td></tr></table></figure>

<h3 id="第2次展开-3-3-2"><a href="#第2次展开-3-3-2" class="headerlink" title="第2次展开 (3.3.2)"></a>第2次展开 (3.3.2)</h3><p>在<code>include/trace/define_trace.h</code>中(linux-5.10.161):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRACE_EVENT(name, proto, args, tstruct, assign, print)  \</span></span><br><span class="line">        DEFINE_TRACE(name, PARAMS(proto), PARAMS(args))</span><br></pre></td></tr></table></figure>

<p>等等，这不就是第2节<code>DECLARE_TRACE/DEFINE_TRACE</code>的工作吗？没错，<code>TRACE_EVENT</code>的首要任务还是创建tracepoint；然后，它才能让tracepoint作为ftrace的event。这就是接下来的工作。</p>
<h3 id="高阶宏-3-3-3"><a href="#高阶宏-3-3-3" class="headerlink" title="高阶宏 (3.3.3)"></a>高阶宏 (3.3.3)</h3><p>在介绍<code>TRACE_EVENT</code>如何把tracepoint变成ftrace的event之前，先看一个C语言中关于宏的玩法，我把它做高阶宏(HOM: High-Order-Macro)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOGS &#123; HOM(JACK_RUSSELL), HOM(BULL_TERRIER), HOM(ITALIAN_GREYHOUND) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> HOM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOM(a) ENUM_##a</span></span><br><span class="line"><span class="keyword">enum</span> dog_enums DOGS;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> HOM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOM(a) #a</span></span><br><span class="line"><span class="keyword">char</span> *dog_strings[] = DOGS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">dog_to_string</span><span class="params">(<span class="keyword">enum</span> dog_enums dog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog_strings[dog];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义了<code>DOGS</code>这个宏，然后展开它2次。由于每次高阶宏<code>HOM</code>的定义不同，所以展开的结果也不同，分别为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> dog_enums &#123; ENUM_JACK_RUSSELL, ENUM_BULL_TERRIER, ENUM_ITALIAN_GREYHOUND &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *dog_strings[] = &#123; <span class="string">&quot;JACK_RUSSELL&quot;</span>, <span class="string">&quot;BULL_TERRIER&quot;</span>, <span class="string">&quot;ITALIAN_GREYHOUND&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>看清楚了这两点，最后函数<code>dog_to_string()</code>的作用显而易见。</p>
<p><code>TRACE_EVENT</code>的剩下的7次定义，就是反复使用这个trick。都在<code>include/trace/trace_events.h</code>(linux-5.10.161)中：</p>
<p>首先，把<code>TRACE_EVENT</code>定义为高阶宏<code>DECLARE_EVENT_CLASS</code>和<code>DEFINE_EVENT</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRACE_EVENT(name, proto, args, tstruct, assign, print) \</span></span><br><span class="line">        DECLARE_EVENT_CLASS(name,                              \</span><br><span class="line">                             PARAMS(proto),                    \</span><br><span class="line">                             PARAMS(args),                     \</span><br><span class="line">                             PARAMS(tstruct),                  \</span><br><span class="line">                             PARAMS(assign),                   \</span><br><span class="line">                             PARAMS(print));                   \</span><br><span class="line">        DEFINE_EVENT(name, name, PARAMS(proto), PARAMS(args));</span><br></pre></td></tr></table></figure>

<p>接下来，每次重新定义高阶宏，就定义了新的<code>TRACE_EVENT</code>，共7次，都在这个header文件中。接着前2次，从第3次开始记：</p>
<h3 id="第3次展开-3-3-4"><a href="#第3次展开-3-3-4" class="headerlink" title="第3次展开 (3.3.4)"></a>第3次展开 (3.3.4)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field(type, item)             type    item;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field_ext</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field_ext(type, item, filter_type)    type    item;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field_struct</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field_struct(type, item)      type    item;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field_struct_ext</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field_struct_ext(type, item, filter_type)     type    item;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __array(type, item, len)        type    item[len];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __dynamic_array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __dynamic_array(type, item, len) u32 __data_loc_##item;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __string</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __string(item, src) __dynamic_array(char, item, -1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __bitmask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bitmask(item, nr_bits) __dynamic_array(char, item, -1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> TP_STRUCT__entry</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TP_STRUCT__entry(args...) args</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_EVENT_CLASS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_EVENT_CLASS(name, proto, args, tstruct, assign, print)  \</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_raw_</span>##<span class="title">name</span> &#123;</span>                                 \</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">trace_entry</span>      <span class="title">ent</span>;</span>                            \</span><br><span class="line">                tstruct                                                 \</span><br><span class="line">                <span class="keyword">char</span>                    __data[<span class="number">0</span>];                      \</span><br><span class="line">        &#125;;                                                              \</span><br><span class="line">                                                                        \</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_class</span> <span class="title">event_class_</span>##<span class="title">name</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DEFINE_EVENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_EVENT(template, name, proto, args)       \</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span>  __<span class="title">used</span>          \</span></span><br><span class="line"><span class="class">        __<span class="title">attribute__</span>((__<span class="title">aligned__</span>(4))) <span class="title">event_</span>##<span class="title">name</span></span></span><br></pre></td></tr></table></figure>

<p>以<code>sched_switch</code>为例，展开的结果是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trace_event_raw_sched_switch</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trace_entry</span>    <span class="title">ent</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*展开自TP_STRUCT__entry参数，见include/trace/events/sched.h中sched_switch的定义*/</span></span><br><span class="line">  <span class="keyword">char</span>   prev_comm[TASK_COMM_LEN];</span><br><span class="line">  <span class="keyword">pid_t</span>  prev_pid;</span><br><span class="line">  <span class="keyword">int</span>    prev_prio;</span><br><span class="line">  <span class="keyword">long</span>   prev_state;</span><br><span class="line">  <span class="keyword">char</span>   next_comm[TASK_COMM_LEN];</span><br><span class="line">  <span class="keyword">pid_t</span>  next_pid;</span><br><span class="line">  <span class="keyword">int</span>    next_prio;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>   __data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_class</span> <span class="title">event_class_sched_switch</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span>  __<span class="title">used</span>  __<span class="title">attribute__</span>((__<span class="title">aligned__</span>(4))) <span class="title">event_sched_switch</span>;</span></span><br></pre></td></tr></table></figure>

<p>第3.1节中Param-4提到的structure就在此定义，即<code>struct trace_event_raw_sched_switch</code>; probe函数会把它的入参中有用的信息保存到这个结构体中(通过<code>assign</code>函数实现)；由于<code>sched_switch</code>比较简单，这个structure中没有dynamic字段。若有的话，structure中会展开有``__data_loc_##item<code>字段；字段的的真实数据会存在</code>__data<code>中，</code>__data_loc_##item`记录它们的信息。</p>
<p>结构体<code>struct trace_event_call event_sched_switch</code>是整个event信息的入口(貌似其他tracing机制，例如kprobe, uprobe, perf的event-source也使用它)，定义在<code>include/linux/trace_events.h</code>(linux-5.10.161)中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_class</span> *<span class="title">class</span>;</span></span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">char</span>                    *name;</span><br><span class="line">                <span class="comment">/* Set TRACE_EVENT_FL_TRACEPOINT flag when using &quot;tp&quot; */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">tracepoint</span>       *<span class="title">tp</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event</span>      <span class="title">event</span>;</span></span><br><span class="line">        <span class="keyword">char</span>                    *print_fmt;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_filter</span>     *<span class="title">filter</span>;</span></span><br><span class="line">        <span class="keyword">void</span>                    *mod;</span><br><span class="line">        <span class="keyword">void</span>                    *data;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   bit 0:             filter_active</span></span><br><span class="line"><span class="comment">         *   bit 1:             allow trace by non root (cap any)</span></span><br><span class="line"><span class="comment">         *   bit 2:             failed to apply filter</span></span><br><span class="line"><span class="comment">         *   bit 3:             trace internal event (do not enable)</span></span><br><span class="line"><span class="comment">         *   bit 4:             Event was enabled by module</span></span><br><span class="line"><span class="comment">         *   bit 5:             use call filter rather than file filter</span></span><br><span class="line"><span class="comment">         *   bit 6:             Event is a tracepoint</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span>                     flags; <span class="comment">/* static flags of different events */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">        <span class="keyword">int</span>                             perf_refcount;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> __<span class="title">percpu</span>      *<span class="title">perf_events</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog_array</span> __<span class="title">rcu</span>     *<span class="title">prog_array</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>     (*perf_perm)(struct trace_event_call *,</span><br><span class="line">                             struct perf_event *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类型<code>struct trace_event_class</code>也定义在<code>include/linux/trace_events.h</code>(linux-5.10.161)中(后文将看到perf event-source也使用它)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trace_event_class</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>              *system;</span><br><span class="line">        <span class="keyword">void</span>                    *probe;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">        <span class="keyword">void</span>                    *perf_probe;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">int</span>                     (*reg)(struct trace_event_call *event,</span><br><span class="line">                                       <span class="keyword">enum</span> trace_reg type, <span class="keyword">void</span> *data);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_fields</span> *<span class="title">fields_array</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        *(*<span class="title">get_fields</span>)(<span class="title">struct</span> <span class="title">trace_event_call</span> *);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">fields</span>;</span></span><br><span class="line">        <span class="keyword">int</span>                     (*raw_init)(struct trace_event_call *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="第4次展开-3-3-5"><a href="#第4次展开-3-3-5" class="headerlink" title="第4次展开 (3.3.5)"></a>第4次展开 (3.3.5)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field(type, item)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field_ext</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field_ext(type, item, filter_type)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field_struct</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field_struct(type, item)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field_struct_ext</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field_struct_ext(type, item, filter_type)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __array(type, item, len)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __dynamic_array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __dynamic_array(type, item, len)        u32 item;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __string</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __string(item, src) __dynamic_array(char, item, -1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __bitmask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bitmask(item, nr_bits) __dynamic_array(unsigned long, item, -1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_EVENT_CLASS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)  \</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_data_offsets_</span>##<span class="title">call</span> &#123;</span>                        \</span><br><span class="line">                tstruct;                                                \</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DEFINE_EVENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_EVENT(template, name, proto, args)</span></span><br></pre></td></tr></table></figure>

<p>以<code>sched_switch</code>为例，展开的结果是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trace_event_data_offsets_sched_switch</span> &#123;</span></span><br><span class="line">    <span class="comment">//empty</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没错，这里展开了个寂寞，因为<code>sched_switch</code>没有dynamic字段。</p>
<h3 id="第5次展开-3-3-6"><a href="#第5次展开-3-3-6" class="headerlink" title="第5次展开 (3.3.6)"></a>第5次展开 (3.3.6)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __entry</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __entry field</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> TP_printk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TP_printk(fmt, args...) fmt <span class="meta-string">&quot;\n&quot;</span>, args</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_EVENT_CLASS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)  \</span></span><br><span class="line"><span class="keyword">static</span> notrace <span class="keyword">enum</span> <span class="keyword">print_line_t</span>                                        \</span><br><span class="line">trace_raw_output_#<span class="meta">#call(struct trace_iterator *iter, int flags,         \</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event</span> *<span class="title">trace_event</span>)                \</span></span><br><span class="line"><span class="class">&#123;</span>                                                                       \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_seq</span> *<span class="title">s</span> = &amp;<span class="title">iter</span>-&gt;<span class="title">seq</span>;</span>                               \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_seq</span> __<span class="title">maybe_unused</span> *<span class="title">p</span> = &amp;<span class="title">iter</span>-&gt;<span class="title">tmp_seq</span>;</span>            \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_raw_</span>##<span class="title">call</span> *<span class="title">field</span>;</span>                           \</span><br><span class="line">        <span class="keyword">int</span> ret;                                                        \</span><br><span class="line">                                                                        \</span><br><span class="line">        field = (typeof(field))iter-&gt;ent;                               \</span><br><span class="line">                                                                        \</span><br><span class="line">        ret = trace_raw_output_prep(iter, trace_event);                 \</span><br><span class="line">        <span class="keyword">if</span> (ret != TRACE_TYPE_HANDLED)                                  \</span><br><span class="line">                <span class="keyword">return</span> ret;                                             \</span><br><span class="line">                                                                        \</span><br><span class="line">        trace_seq_printf(s, print);                                     \</span><br><span class="line">                                                                        \</span><br><span class="line">        <span class="keyword">return</span> trace_handle_return(s);                                  \</span><br><span class="line">&#125;                                                                       \</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_functions</span> <span class="title">trace_event_type_funcs_</span>##<span class="title">call</span> = &#123;</span>   \</span><br><span class="line">        .trace                  = trace_raw_output_##call,              \</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>展开为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> notrace <span class="keyword">enum</span> <span class="keyword">print_line_t</span></span><br><span class="line">trace_raw_output_sched_switch(struct trace_iterator *iter, <span class="keyword">int</span> flags,</span><br><span class="line">            struct trace_event *trace_event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_seq</span> *<span class="title">s</span> = &amp;<span class="title">iter</span>-&gt;<span class="title">seq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_seq</span> __<span class="title">maybe_unused</span> *<span class="title">p</span> = &amp;<span class="title">iter</span>-&gt;<span class="title">tmp_seq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_raw_sched_switch</span> *<span class="title">field</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    field = (typeof(field))iter-&gt;ent;</span><br><span class="line"></span><br><span class="line">    ret = trace_raw_output_prep(iter, trace_event);</span><br><span class="line">    <span class="keyword">if</span> (ret != TRACE_TYPE_HANDLED)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    trace_seq_printf(s, print);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> trace_handle_return(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_functions</span> <span class="title">trace_event_type_funcs_sched_switch</span> = &#123;</span></span><br><span class="line">    .trace            = trace_raw_output_sched_switch,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这一步定义的函数<code>trace_raw_output_sched_switch()</code>用于print <code>struct trace_event_raw_sched_switch</code>结构体，即读ftrace ring buffer中的entry结构体，以可读的格式写入用户态output buffer；这个结构体应该由probe创建，存在于ftrace ring buffer中；本函数把它打印成可读形式。注意，这里有一些“奇技淫巧”:</p>
<ul>
<li><code>field</code>好像是一个没用的变量；实际上，注意前面有<code>#define __entry field</code>，所以，只要使用<code>__entry</code>就是使用<code>field</code>；</li>
<li>可是<code>__entry</code>也没有被使用啊！不然。首先<code>trace_seq_printf(s, print);</code>中的<code>print</code>是第3.2节中<code>sched_switch</code>定义中的<code>TP_printk</code>。这里<code>TP_printk</code>的定义是，把它的<code>fmt</code>和<code>args</code>取出来。最终<code>trace_seq_printf</code>语句变成:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">trace_seq_printf(s, <span class="string">&quot;prev_comm=%s prev_pid=%d prev_prio=%d prev_state=%s%s ==&gt; next_comm=%s next_pid=%d next_prio=%d&quot;</span>,</span><br><span class="line">        __entry-&gt;prev_comm, __entry-&gt;prev_pid, __entry-&gt;prev_prio,</span><br><span class="line"></span><br><span class="line">        (__entry-&gt;prev_state &amp; (TASK_REPORT_MAX - <span class="number">1</span>)) ?</span><br><span class="line">          __print_flags(__entry-&gt;prev_state &amp; (TASK_REPORT_MAX - <span class="number">1</span>), <span class="string">&quot;|&quot;</span>,</span><br><span class="line">                        &#123; TASK_INTERRUPTIBLE, <span class="string">&quot;S&quot;</span> &#125;,</span><br><span class="line">                        &#123; TASK_UNINTERRUPTIBLE, <span class="string">&quot;D&quot;</span> &#125;,</span><br><span class="line">                        &#123; __TASK_STOPPED, <span class="string">&quot;T&quot;</span> &#125;,</span><br><span class="line">                        &#123; __TASK_TRACED, <span class="string">&quot;t&quot;</span> &#125;,</span><br><span class="line">                        &#123; EXIT_DEAD, <span class="string">&quot;X&quot;</span> &#125;,</span><br><span class="line">                        &#123; EXIT_ZOMBIE, <span class="string">&quot;Z&quot;</span> &#125;,</span><br><span class="line">                        &#123; TASK_PARKED, <span class="string">&quot;P&quot;</span> &#125;,</span><br><span class="line">                        &#123; TASK_DEAD, <span class="string">&quot;I&quot;</span> &#125;) :</span><br><span class="line">          <span class="string">&quot;R&quot;</span>,</span><br><span class="line"></span><br><span class="line">        __entry-&gt;prev_state &amp; TASK_REPORT_MAX ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        __entry-&gt;next_comm, __entry-&gt;next_pid, __entry-&gt;next_prio)</span><br></pre></td></tr></table></figure>

<h3 id="第6次展开-3-3-7"><a href="#第6次展开-3-3-7" class="headerlink" title="第6次展开 (3.3.7)"></a>第6次展开 (3.3.7)</h3><p>定义一个函数，ftrace框架使用，不展开。</p>
<h3 id="第7次展开-3-3-8"><a href="#第7次展开-3-3-8" class="headerlink" title="第7次展开 (3.3.8)"></a>第7次展开 (3.3.8)</h3><p>定义一个函数，用于计算各个dynamic字段的length和offset；<code>sched_switch</code>的<code>TP_printk</code>中没有dynamic字段，略过；</p>
<h3 id="第8次展开-3-3-9"><a href="#第8次展开-3-3-9" class="headerlink" title="第8次展开 (3.3.9)"></a>第8次展开 (3.3.9)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __entry</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __entry entry</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field(type, item)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __field_struct</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __field_struct(type, item)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __array(type, item, len)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __assign_bitmask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __assign_bitmask(dst, src, nr_bits)                                     \</span></span><br><span class="line">        <span class="built_in">memcpy</span>(__get_bitmask(dst), (src), __bitmask_size_in_bytes(nr_bits))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> TP_fast_assign</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TP_fast_assign(args...) args</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __perf_count</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __perf_count(c) (c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __perf_task</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __perf_task(t)  (t)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_EVENT_CLASS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)  \</span></span><br><span class="line">                                                                        \</span><br><span class="line"><span class="keyword">static</span> notrace <span class="keyword">void</span>                                                     \</span><br><span class="line">trace_event_raw_event_#<span class="meta">#call(void *__data, proto)                       \</span></span><br><span class="line">&#123;                                                                       \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_file</span> *<span class="title">trace_file</span> = __<span class="title">data</span>;</span>                   \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_data_offsets_</span>##<span class="title">call</span> __<span class="title">maybe_unused</span> __<span class="title">data_offsets</span>;</span>\</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_buffer</span> <span class="title">fbuffer</span>;</span>                              \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_raw_</span>##<span class="title">call</span> *<span class="title">entry</span>;</span>                           \</span><br><span class="line">        <span class="keyword">int</span> __data_size;                                                \</span><br><span class="line">                                                                        \</span><br><span class="line">        <span class="keyword">if</span> (trace_trigger_soft_disabled(trace_file))                    \</span><br><span class="line">                <span class="keyword">return</span>;                                                 \</span><br><span class="line">                                                                        \</span><br><span class="line">        __data_size = trace_event_get_offsets_##call(&amp;__data_offsets, args); \</span><br><span class="line">                                                                        \</span><br><span class="line">        entry = trace_event_buffer_reserve(&amp;fbuffer, trace_file,        \</span><br><span class="line">                                 <span class="keyword">sizeof</span>(*entry) + __data_size);         \</span><br><span class="line">                                                                        \</span><br><span class="line">        <span class="keyword">if</span> (!entry)                                                     \</span><br><span class="line">                <span class="keyword">return</span>;                                                 \</span><br><span class="line">                                                                        \</span><br><span class="line">        tstruct                                                         \</span><br><span class="line">                                                                        \</span><br><span class="line">        &#123; assign; &#125;                                                     \</span><br><span class="line">                                                                        \</span><br><span class="line">        trace_event_buffer_commit(&amp;fbuffer);                            \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展开为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> notrace <span class="keyword">void</span></span><br><span class="line">trace_event_raw_event_sched_switch(<span class="keyword">void</span> *__data, <span class="keyword">bool</span> preempt, struct task_struct *prev, struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_file</span> *<span class="title">trace_file</span> = __<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_data_offsets_sched_switch</span> __<span class="title">maybe_unused</span> __<span class="title">data_offsets</span>;</span>\</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_buffer</span> <span class="title">fbuffer</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_raw_sched_switch</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">int</span> __data_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_trigger_soft_disabled(trace_file))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    __data_size = trace_event_get_offsets_sched_switch(&amp;__data_offsets, args);</span><br><span class="line"></span><br><span class="line">    entry = trace_event_buffer_reserve(&amp;fbuffer, trace_file,</span><br><span class="line">                 <span class="keyword">sizeof</span>(*entry) + __data_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* tstruct 展开为空，因为没有dynamic字段*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&#123; assign &#125;展开为*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(__entry-&gt;next_comm, next-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">        __entry-&gt;prev_pid       = prev-&gt;pid;</span><br><span class="line">        __entry-&gt;prev_prio      = prev-&gt;prio;</span><br><span class="line">        __entry-&gt;prev_state     = __trace_sched_switch_state(preempt, prev);</span><br><span class="line">        <span class="built_in">memcpy</span>(__entry-&gt;prev_comm, prev-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">        __entry-&gt;next_pid       = next-&gt;pid;</span><br><span class="line">        __entry-&gt;next_prio      = next-&gt;prio;</span><br><span class="line">        <span class="comment">/* XXX SCHED_DEADLINE */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_event_buffer_commit(&amp;fbuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是我们心心念念的probe函数，用了和前面第5次展开一样的“奇技淫巧”，不再赘述。如第3.1节解释Param-4和Param-5时所述：</p>
<ul>
<li><code>trace_event_buffer_reserve</code>: 在ftrace ring buffer上分配entry(<code>trace_event_raw_sched_switch</code>类型的结构体);</li>
<li><code>assign</code>: 把入参中的有用信息保存到<code>entry</code>；</li>
<li><code>trace_event_buffer_commit</code>: commit entry到ftrace ring buffer;</li>
</ul>
<p>另外: <code>trace_event_get_offsets_sched_switch</code>用于计算dynamic字段的长度；<code>sched_switch</code>没有dynamic字段，不提。</p>
<h3 id="第9次展开-3-3-10"><a href="#第9次展开-3-3-10" class="headerlink" title="第9次展开 (3.3.10)"></a>第9次展开 (3.3.10)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_EVENT_CLASS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)  \</span></span><br><span class="line">_TRACE_PERF_PROTO(call, PARAMS(proto));                                 \</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> print_fmt_#<span class="meta">#call[] = print;                                 \</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_class</span> __<span class="title">used</span> __<span class="title">refdata</span> <span class="title">event_class_</span>##<span class="title">call</span> = &#123;</span> \</span><br><span class="line">        .system                 = TRACE_SYSTEM_STRING,                  \</span><br><span class="line">        .fields_array           = trace_event_fields_##call,            \</span><br><span class="line">        .fields                 = LIST_HEAD_INIT(event_class_##call.fields),\</span><br><span class="line">        .raw_init               = trace_event_raw_init,                 \</span><br><span class="line">        .probe                  = trace_event_raw_event_##call,         \</span><br><span class="line">        .reg                    = trace_event_reg,                      \</span><br><span class="line">        _TRACE_PERF_INIT(call)                                          \</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DEFINE_EVENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_EVENT(template, call, proto, args)                       \</span></span><br><span class="line">                                                                        \</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> __<span class="title">used</span> <span class="title">event_</span>##<span class="title">call</span> = &#123;</span>                  \</span><br><span class="line">        .class                  = &amp;event_class_##<span class="keyword">template</span>,              \</span><br><span class="line">        &#123;                                                               \</span><br><span class="line">                .tp                     = &amp;__tracepoint_##call,         \</span><br><span class="line">        &#125;,                                                              \</span><br><span class="line">        .event.funcs            = &amp;trace_event_type_funcs_##<span class="keyword">template</span>,   \</span><br><span class="line">        .print_fmt              = print_fmt_##<span class="keyword">template</span>,                 \</span><br><span class="line">        .flags                  = TRACE_EVENT_FL_TRACEPOINT,            \</span><br><span class="line">&#125;;                                                                      \</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> __<span class="title">used</span>                                   \</span></span><br><span class="line"><span class="class">__<span class="title">section</span>(&quot;_<span class="title">ftrace_events</span>&quot;) *__<span class="title">event_</span>##<span class="title">call</span> = &amp;<span class="title">event_</span>##<span class="title">call</span></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p>展开为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> print_fmt_sched_switch[] = print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_class</span> __<span class="title">used</span> __<span class="title">refdata</span> <span class="title">event_class_sched_switch</span> = &#123;</span></span><br><span class="line">    .system            = TRACE_SYSTEM_STRING,</span><br><span class="line">    .fields_array      = trace_event_fields_sched_switch,</span><br><span class="line">    .fields            = LIST_HEAD_INIT(event_class_sched_switch.fields),</span><br><span class="line">    .raw_init          = trace_event_raw_init,</span><br><span class="line">    .probe             = trace_event_raw_event_sched_switch,</span><br><span class="line">    .reg               = trace_event_reg,</span><br><span class="line">    _TRACE_PERF_INIT(call)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> __<span class="title">used</span> <span class="title">event_sched_switch</span> = &#123;</span></span><br><span class="line">    .class            = &amp;event_class_sched_switch,</span><br><span class="line">    &#123;</span><br><span class="line">        .tp            = &amp;__tracepoint_sched_switch,</span><br><span class="line">    &#125;,</span><br><span class="line">    .event.funcs        = &amp;trace_event_type_funcs_sched_switch,</span><br><span class="line">    .print_fmt        = print_fmt_sched_switch,</span><br><span class="line">    .flags            = TRACE_EVENT_FL_TRACEPOINT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> __<span class="title">used</span> __<span class="title">section</span>(&quot;_<span class="title">ftrace_events</span>&quot;) *__<span class="title">event_sched_switch</span> = &amp;<span class="title">event_sched_switch</span>;</span></span><br></pre></td></tr></table></figure>

<p>这里初始化第3次展开得到的<code>event_class_sched_switch</code>和<code>event_sched_switch</code>。其中最重要的是：</p>
<ul>
<li><code>event_sched_switch.class</code>指向<code>event_class_sched_switch</code>；</li>
<li><code>event_class_sched_switch.probe</code>指向第8次展开得到的probe函数；</li>
<li><code>event_sched_switch.tp</code>指向<code>struct tracepoint</code>类型的对象<code>__tracepoint_sched_switch</code>；这是第1次展开时定义的。详情在第2节介绍了，只是那时没有以<code>sched_switch</code>为例子，见第2节<code>__DECLARE_TRACE</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tracepoint</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;               <span class="comment">/* Tracepoint name */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">static_key</span> <span class="title">key</span>;</span>          <span class="comment">/*用于确定是否enabled*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">static_call_key</span> *<span class="title">static_call_key</span>;</span></span><br><span class="line">        <span class="keyword">void</span> *static_call_tramp;</span><br><span class="line">        <span class="keyword">void</span> *iterator;</span><br><span class="line">        <span class="keyword">int</span> (*regfunc)(<span class="keyword">void</span>);                <span class="comment">/*在add probe之前调用*/</span></span><br><span class="line">        <span class="keyword">void</span> (*unregfunc)(<span class="keyword">void</span>);             <span class="comment">/*在remove probe之后调用?*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tracepoint_func</span> __<span class="title">rcu</span> *<span class="title">funcs</span>;</span> <span class="comment">/*probe函数, 允许有多个*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如前所述，<code>struct trace_event_call event_sched_switch</code>是ftrace event的入口，它的指针被存放在<code>_ftrace_events</code>段。系统启动阶段，ftrace初始化时，扫描<code>_ftrace_events</code>段，对于其中的每一个<code>struct trace_event_call</code>调用<code>event_init</code>进行初始化。</p>
<h3 id="回顾-3-3-11"><a href="#回顾-3-3-11" class="headerlink" title="回顾 (3.3.11)"></a>回顾 (3.3.11)</h3><p>回顾第3.2节的猜测:</p>
<ul>
<li>hook函数调用probe函数，它们的prototype一样。真实情况是：它们虽然不相同，也非常类似。hook函数是<code>__DECLARE_TRACE</code>中的<code>trace_##name</code>展开的，probe函数见第8次展开：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace_sched_switch</span><span class="params">(<span class="keyword">bool</span> preempt, struct task_struct *prev, struct task_struct *next)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace_event_raw_event_sched_switch</span><span class="params">(<span class="keyword">void</span> *__data, <span class="keyword">bool</span> preempt, struct task_struct *prev, struct task_struct *next)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>probe函数在ftrace ring buffer中构造一个entry，类型是<code>TP_STRUCT__entry</code>：probe函数确实在ftrace ring buffer中构造一个entry，类型是第3次展开得到的<code>struct trace_event_raw_sched_switch</code>；<code>TP_STRUCT__entry</code>是其中的一些字段。大体正确。</li>
<li>probe函数调用<code>assign</code>给entry赋值：是的，probe函数<code>trace_event_raw_event_sched_switch</code>中包含<code>assign</code>中的语句。</li>
<li>ftrace调用<code>TP_printk</code>显示trace到的信息：是的，见第5次展开的<code>trace_raw_output_sched_switch</code>函数：print entry (即读ftrace ring buffer中的entry，以可读的格式写入用户态output buffer);</li>
</ul>
<p>第1次和第2次展开，等价于与旧方式<code>DECLARE_TRACE/DEFINE_TRACE</code>；第3次定义了entry的类型；第5次展开定义了打印entry的函数；第8次定义probe函数；第9次把以上所有定义汇集到入口结构体<code>event_sched_switch</code>。第4次是处理dynamic字段的，第6和第7次是fatrace框架相关的一些细节，忽略。</p>
<p>最终，得到的是这样一个结构：</p>


<h3 id="ftrace-init-3-3-12"><a href="#ftrace-init-3-3-12" class="headerlink" title="ftrace init (3.3.12)"></a>ftrace init (3.3.12)</h3><p>Ftrace初始化是一个复杂的过程，只看和tracepoint相关部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">start_kernel()</span><br><span class="line">    trace_init()</span><br><span class="line">        trace_event_init()</span><br><span class="line">        event_trace_enable()</span><br><span class="line">        &#123;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                for_each_event(iter, __start_ftrace_events, __stop_ftrace_events) &#123;</span><br><span class="line"></span><br><span class="line">                  call = *iter;</span><br><span class="line">                  ret = event_init(call);</span><br><span class="line">                  <span class="keyword">if</span> (!ret)</span><br><span class="line">                    list_add(&amp;call-&gt;<span class="built_in">list</span>, &amp;ftrace_events);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                __trace_early_add_events(tr);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>event_trace_enable()</code>中：</p>
<ul>
<li>扫描<code>_ftrace_events</code>段，对其中的每个<code>struct trace_event_call</code>结构体<code>call</code>：1. 调用<code>event_init(call)</code>；2. 把<code>call</code>添加到<code>ftrace_events</code>(全局变量，ftrace的所有event的列表)；</li>
<li><code>__trace_early_add_events</code>函数里再次扫描<code>_ftrace_events</code>段，为每个<code>call</code>创建<code>struct trace_event_file</code>文件。这个文件应该是<code>/sys/kernel/debug/tracing/events/sched/sched_switch/enable</code>；看probe函数(第8次展开)，通过这个文件判断event是否soft disabled。第3.2节中演练也是<code>echo 1</code>到这个文件来enable event;</li>
</ul>
<h3 id="enable-event-3-3-13"><a href="#enable-event-3-3-13" class="headerlink" title="enable event (3.3.13)"></a>enable event (3.3.13)</h3><p>第2节说，要通<code>register_trace_##name</code>来把probe关联到hook上；且在第2节<code>__DECLARE_TRACE</code>中可以看到<code>register_trace_##name</code>调用<code>tracepoint_probe_register</code>。所以，我们有理由猜测，要enable event，要么调用<code>register_trace_##name</code>，要么调用<code>tracepoint_probe_register</code>。</p>
<p>在第3.2节演练时，通过<code>echo 1 &gt; /sys/kernel/debug/tracing/events/sched/sched_switch/enable</code>来enable event。Ftrace通过一个虚拟的filesystem和user交互：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ftrace_enable_fops</span> = &#123;</span></span><br><span class="line">        .open = tracing_open_generic,</span><br><span class="line">        .read = event_enable_read,</span><br><span class="line">        .write = event_enable_write,</span><br><span class="line">        .llseek = default_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以<code>echo 1</code>触发的是<code>event_enable_write</code>函数。我们看看它是否会调用到<code>register_trace_##name</code>或<code>tracepoint_probe_register</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">event_enable_write(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *ubuf, <span class="keyword">size_t</span> cnt,</span><br><span class="line">                   <span class="keyword">loff_t</span> *ppos)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_file</span> *<span class="title">file</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = kstrtoul_from_user(ubuf, cnt, <span class="number">10</span>, &amp;val);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = tracing_update_buffers();</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (val) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                ret = -ENODEV;</span><br><span class="line">                mutex_lock(&amp;event_mutex);</span><br><span class="line">                file = event_file_data(filp);</span><br><span class="line">                <span class="keyword">if</span> (likely(file))</span><br><span class="line">                        ret = ftrace_event_enable_disable(file, val);</span><br><span class="line">                mutex_unlock(&amp;event_mutex);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *ppos += cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret ? ret : cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，这个函数是非常规范的文件系统write函数：入参有文件指针<code>filp</code>，数据buffer <code>ubuf</code>, 数据长度<code>cnt</code>，以及写入到文件中的位置<code>ppos</code>；这里数据应该”1”，位置应该是0；文件指针<code>filp</code>是不是<code>/sys/kernel/debug/tracing/events/sched/sched_switch/enable</code>呢？应该是的，<code>event_file_data</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">event_file_data</span><span class="params">(struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> READ_ONCE(file_inode(filp)-&gt;i_private);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>filp</code>的<code>inode</code>的<code>i_private</code>就是<code>/sys/kernel/debug/tracing/events/sched/sched_switch/enable</code>。</p>
<p>当写入的是”0”或”1”时，就会调用<code>ftrace_event_enable_disable()</code>，<code>val</code>是”0”或”1”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ftrace_event_enable_disable</span><span class="params">(struct trace_event_file *file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> enable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __ftrace_event_enable_disable(file, enable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __ftrace_event_enable_disable(struct trace_event_file *file,</span><br><span class="line">                                         <span class="keyword">int</span> enable, <span class="keyword">int</span> soft_disable)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> *<span class="title">call</span> = <span class="title">file</span>-&gt;<span class="title">event_call</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_array</span> *<span class="title">tr</span> = <span class="title">file</span>-&gt;<span class="title">tr</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> file_flags = file-&gt;flags;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> disable;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (enable) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (!(file-&gt;flags &amp; EVENT_FILE_FL_ENABLED)) &#123;</span><br><span class="line"></span><br><span class="line">                        ......</span><br><span class="line"></span><br><span class="line">                        ret = call-&gt;class-&gt;reg(call, TRACE_REG_REGISTER, file);</span><br><span class="line"></span><br><span class="line">                        ......</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看第9次展开知道，<code>call-&gt;class-&gt;reg</code>是<code>trace_event_reg</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trace_event_reg</span><span class="params">(struct trace_event_call *call,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">enum</span> trace_reg type, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_file</span> *<span class="title">file</span> = <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">        WARN_ON(!(call-&gt;flags &amp; TRACE_EVENT_FL_TRACEPOINT));</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_REGISTER:</span><br><span class="line">                <span class="keyword">return</span> tracepoint_probe_register(call-&gt;tp,</span><br><span class="line">                                                 call-&gt;class-&gt;probe,</span><br><span class="line">                                                 file);</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_UNREGISTER:</span><br><span class="line">                tracepoint_probe_unregister(call-&gt;tp,</span><br><span class="line">                                            call-&gt;class-&gt;probe,</span><br><span class="line">                                            file);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_REGISTER:</span><br><span class="line">                <span class="keyword">return</span> tracepoint_probe_register(call-&gt;tp,</span><br><span class="line">                                                 call-&gt;class-&gt;perf_probe,</span><br><span class="line">                                                 call);</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_UNREGISTER:</span><br><span class="line">                tracepoint_probe_unregister(call-&gt;tp,</span><br><span class="line">                                            call-&gt;class-&gt;perf_probe,</span><br><span class="line">                                            call);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_OPEN:</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_CLOSE:</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_ADD:</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_DEL:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(trace_event_reg);</span><br></pre></td></tr></table></figure>

<p>符合前面的猜测：要enable event，要么调用<code>register_trace_##name</code>，要么调用<code>tracepoint_probe_register</code>；这里调用了后者。</p>
<h3 id="小结-3-3-14"><a href="#小结-3-3-14" class="headerlink" title="小结 (3.3.14)"></a>小结 (3.3.14)</h3><p>至此，搞清楚了tracepoint和ftrace的关系：</p>
<ul>
<li>tracepoint是静态的hook(内核代码中的<code>trace_##name</code>)加上动态register/unregister的probe；</li>
<li>使用<code>DECLARE_TRACE/DEFINE_TRACE</code>可以创建一个tracepoint；这是内核代码开发者的事。想要使用它，需要调用开发一个内核模块，实现probe并register；</li>
<li>上述使用不是很方便，所以，随着系统演进，创建tracepoint时，自动附带一个probe，由ftrace来register，即tracepoint自动作为ftrace的event-source；<code>TRACE_EVENT</code>宏定义了很多复杂的数据结构和函数来实现这个目的。</li>
<li>当然，tracepoint和ftrace不是绑定的，还可以像以前那样使用tracepoint；另外，tracepoint也可以作为其它tracer(如perf, LTTng, SystemTap)的event-source；</li>
</ul>
<h1 id="作为perf的event-source-4"><a href="#作为perf的event-source-4" class="headerlink" title="作为perf的event-source (4)"></a>作为perf的event-source (4)</h1><p>根据tracepoint的原理，perf要使用它，也是要实现一个probe函数并register。其实，从第3.3节中第3次展开已经看到一些端倪:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trace_event_class</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>              *system;</span><br><span class="line">        <span class="keyword">void</span>                    *probe;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">        <span class="keyword">void</span>                    *perf_probe;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">int</span>                     (*reg)(struct trace_event_call *event,</span><br><span class="line">                                       <span class="keyword">enum</span> trace_reg type, <span class="keyword">void</span> *data);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_fields</span> *<span class="title">fields_array</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        *(*<span class="title">get_fields</span>)(<span class="title">struct</span> <span class="title">trace_event_call</span> *);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">fields</span>;</span></span><br><span class="line">        <span class="keyword">int</span>                     (*raw_init)(struct trace_event_call *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当配置了perf时，<code>struct trace_event_class event_class_sched_switch</code>就定义了一个<code>perf_probe</code>指针。而第9次展开是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_class</span> __<span class="title">used</span> __<span class="title">refdata</span> <span class="title">event_class_sched_switch</span> = &#123;</span></span><br><span class="line">    .system            = TRACE_SYSTEM_STRING,</span><br><span class="line">    .fields_array      = trace_event_fields_sched_switch,</span><br><span class="line">    .fields            = LIST_HEAD_INIT(event_class_sched_switch.fields),</span><br><span class="line">    .raw_init          = trace_event_raw_init,</span><br><span class="line">    .probe             = trace_event_raw_event_sched_switch,</span><br><span class="line">    .reg               = trace_event_reg,</span><br><span class="line">    _TRACE_PERF_INIT(call)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中<code>_TRACE_PERF_INIT</code>被忽略了，它的定义是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TRACE_PERF_INIT(call)                   \</span></span><br><span class="line">        .perf_probe             = perf_trace_##call,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以，完全展开是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_class</span> __<span class="title">used</span> __<span class="title">refdata</span> <span class="title">event_class_sched_switch</span> = &#123;</span></span><br><span class="line">    .system            = TRACE_SYSTEM_STRING,</span><br><span class="line">    .fields_array      = trace_event_fields_sched_switch,</span><br><span class="line">    .fields            = LIST_HEAD_INIT(event_class_sched_switch.fields),</span><br><span class="line">    .raw_init          = trace_event_raw_init,</span><br><span class="line">    .probe             = trace_event_raw_event_sched_switch,</span><br><span class="line">    .reg               = trace_event_reg,</span><br><span class="line">    .perf_probe        = perf_trace_sched_switch,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们要找到<code>perf_trace_sched_switch</code>，它就是为perf提供的probe。第3.3节中，为了支持ftrace，<code>TRACE_EVENT</code>被展开7次，本节还是熟悉的配方，为了支持perf，<code>TRACE_EVENT</code>在include/trace/perf.h(linux-5.10.161)继续展开:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __entry</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __entry entry</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __get_dynamic_array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __get_dynamic_array(field)      \</span></span><br><span class="line">                ((<span class="keyword">void</span> *)__entry + (__entry-&gt;__data_loc_##field &amp; <span class="number">0xffff</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __get_dynamic_array_len</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __get_dynamic_array_len(field)  \</span></span><br><span class="line">                ((__entry-&gt;__data_loc_##field &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __get_str</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __get_str(field) ((char *)__get_dynamic_array(field))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __get_bitmask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __get_bitmask(field) (char *)__get_dynamic_array(field)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __perf_count</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __perf_count(c) (__count = (c))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> __perf_task</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __perf_task(t)  (__task = (t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_EVENT_CLASS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)  \</span></span><br><span class="line"><span class="keyword">static</span> notrace <span class="keyword">void</span>                                                     \</span><br><span class="line">perf_trace_#<span class="meta">#call(void *__data, proto)                                  \</span></span><br><span class="line">&#123;                                                                       \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> *<span class="title">event_call</span> = __<span class="title">data</span>;</span>                   \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_data_offsets_</span>##<span class="title">call</span> __<span class="title">maybe_unused</span> __<span class="title">data_offsets</span>;</span>\</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_raw_</span>##<span class="title">call</span> *<span class="title">entry</span>;</span>                           \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *__<span class="title">regs</span>;</span>                                         \</span><br><span class="line">        u64 __count = <span class="number">1</span>;                                                \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">task</span> = <span class="title">NULL</span>;</span>                              \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">head</span>;</span>                                        \</span><br><span class="line">        <span class="keyword">int</span> __entry_size;                                               \</span><br><span class="line">        <span class="keyword">int</span> __data_size;                                                \</span><br><span class="line">        <span class="keyword">int</span> rctx;                                                       \</span><br><span class="line">                                                                        \</span><br><span class="line">        __data_size = trace_event_get_offsets_##call(&amp;__data_offsets, args); \</span><br><span class="line">                                                                        \</span><br><span class="line">        head = this_cpu_ptr(event_call-&gt;perf_events);                   \</span><br><span class="line">        <span class="keyword">if</span> (!bpf_prog_array_valid(event_call) &amp;&amp;                        \</span><br><span class="line">            __builtin_constant_p(!__task) &amp;&amp; !__task &amp;&amp;                 \</span><br><span class="line">            hlist_empty(head))                                          \</span><br><span class="line">                <span class="keyword">return</span>;                                                 \</span><br><span class="line">                                                                        \</span><br><span class="line">        __entry_size = ALIGN(__data_size + <span class="keyword">sizeof</span>(*entry) + <span class="keyword">sizeof</span>(u32),\</span><br><span class="line">                             <span class="keyword">sizeof</span>(u64));                              \</span><br><span class="line">        __entry_size -= <span class="keyword">sizeof</span>(u32);                                    \</span><br><span class="line">                                                                        \</span><br><span class="line">        entry = perf_trace_buf_alloc(__entry_size, &amp;__regs, &amp;rctx);     \</span><br><span class="line">        <span class="keyword">if</span> (!entry)                                                     \</span><br><span class="line">                <span class="keyword">return</span>;                                                 \</span><br><span class="line">                                                                        \</span><br><span class="line">        perf_fetch_caller_regs(__regs);                                 \</span><br><span class="line">                                                                        \</span><br><span class="line">        tstruct                                                         \</span><br><span class="line">                                                                        \</span><br><span class="line">        &#123; assign; &#125;                                                     \</span><br><span class="line">                                                                        \</span><br><span class="line">        perf_trace_run_bpf_submit(entry, __entry_size, rctx,            \</span><br><span class="line">                                  event_call, __count, __regs,          \</span><br><span class="line">                                  head, __task);                        \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展开为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> notrace <span class="keyword">void</span></span><br><span class="line">perf_trace_sched_switch(<span class="keyword">void</span> *__data, <span class="keyword">bool</span> preempt, struct task_struct *prev, struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> *<span class="title">event_call</span> = __<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_data_offsets_sched_switch</span> __<span class="title">maybe_unused</span> __<span class="title">data_offsets</span>;</span>\</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_raw_sched_switch</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *__<span class="title">regs</span>;</span></span><br><span class="line">    u64 __count = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *__<span class="title">task</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> __entry_size;</span><br><span class="line">    <span class="keyword">int</span> __data_size;</span><br><span class="line">    <span class="keyword">int</span> rctx;</span><br><span class="line"></span><br><span class="line">    __data_size = trace_event_get_offsets_sched_switch(&amp;__data_offsets, args);</span><br><span class="line"></span><br><span class="line">    head = this_cpu_ptr(event_call-&gt;perf_events);</span><br><span class="line">    <span class="keyword">if</span> (!bpf_prog_array_valid(event_call) &amp;&amp;</span><br><span class="line">        __builtin_constant_p(!__task) &amp;&amp; !__task &amp;&amp;</span><br><span class="line">        hlist_empty(head))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    __entry_size = ALIGN(__data_size + <span class="keyword">sizeof</span>(*entry) + <span class="keyword">sizeof</span>(u32),\</span><br><span class="line">                         <span class="keyword">sizeof</span>(u64));</span><br><span class="line">    __entry_size -= <span class="keyword">sizeof</span>(u32);</span><br><span class="line"></span><br><span class="line">    entry = perf_trace_buf_alloc(__entry_size, &amp;__regs, &amp;rctx);</span><br><span class="line">    <span class="keyword">if</span> (!entry)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    perf_fetch_caller_regs(__regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* tstruct 展开为空，因为没有dynamic字段*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*&#123; assign &#125;展开为*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(__entry-&gt;next_comm, next-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">        __entry-&gt;prev_pid       = prev-&gt;pid;</span><br><span class="line">        __entry-&gt;prev_prio      = prev-&gt;prio;</span><br><span class="line">        __entry-&gt;prev_state     = __trace_sched_switch_state(preempt, prev);</span><br><span class="line">        <span class="built_in">memcpy</span>(__entry-&gt;prev_comm, prev-&gt;comm, TASK_COMM_LEN);</span><br><span class="line">        __entry-&gt;next_pid       = next-&gt;pid;</span><br><span class="line">        __entry-&gt;next_prio      = next-&gt;prio;</span><br><span class="line">        <span class="comment">/* XXX SCHED_DEADLINE */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    perf_trace_run_bpf_submit(entry, __entry_size, rctx,</span><br><span class="line">                              event_call, __count, __regs,</span><br><span class="line">                              head, __task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不出所料，我们找到了<code>perf_trace_sched_switch</code>。看上去是不是和第3.3节第8次展开很像？是的，<strong>它就是perf版本的probe函数</strong>，所做的事情也非常类似:</p>
<ul>
<li>在perf ring buffer上分配entry(<code>trace_event_raw_sched_switch</code>类型的结构体)，而不是在ftrace ring buffer上。</li>
<li><code>assign</code>: 把入参中的有用信息保存到<code>entry</code>；这一点是一模一样的；</li>
<li><code>perf_trace_run_bpf_submit</code>: commit entry;</li>
</ul>
<p>同样，<code>trace_event_get_offsets_sched_switch</code>计算dynamic字段的长度；<code>sched_switch</code>没有dynamic字段，不提；</p>
<p>有了perf的probe函数，想必它也是enable的时候register的。其实第3.3节中”enable event”小节中，<code>trace_event_reg</code>函数已经处理了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trace_event_reg</span><span class="params">(struct trace_event_call *call,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">enum</span> trace_reg type, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_REGISTER:</span><br><span class="line">                <span class="keyword">return</span> tracepoint_probe_register(call-&gt;tp,</span><br><span class="line">                                                 call-&gt;class-&gt;perf_probe,</span><br><span class="line">                                                 call);</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_UNREGISTER:</span><br><span class="line">                tracepoint_probe_unregister(call-&gt;tp,</span><br><span class="line">                                            call-&gt;class-&gt;perf_probe,</span><br><span class="line">                                            call);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_OPEN:</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_CLOSE:</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_ADD:</span><br><span class="line">        <span class="keyword">case</span> TRACE_REG_PERF_DEL:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(trace_event_reg);</span><br></pre></td></tr></table></figure>

<p>用户态程序通过syscall <code>perf_event_open()</code>来enable perf event；这个函数定义在<code>kernel/events/core.c</code>(linux-5.10.161)中；<code>perf_event_open()</code>调用<code>pmu-&gt;event_init</code>来初始化event；对于tracepoint类型的event来说，<code>pmu</code>就是<code>struct pmu perf_tracepoint</code>；其<code>event_init</code>指向<code>perf_tp_event_init()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">perf_tp_event_init()</span><br><span class="line">    perf_trace_init()</span><br><span class="line">        perf_trace_event_init()</span><br><span class="line">            perf_trace_event_reg()</span><br><span class="line">            &#123;</span><br><span class="line">                tp_event-&gt;<span class="class"><span class="keyword">class</span>-&gt;<span class="title">reg</span>(<span class="title">tp_event</span>, <span class="title">TRACE_REG_PERF_REGISTER</span>, <span class="title">NULL</span>);</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>tp_event-&gt;class-&gt;reg</code>就是函数<code>trace_event_reg</code>，传入的<code>type</code>是<code>TRACE_REG_PERF_REGISTER</code>，所以会调用: <code>tracepoint_probe_register(..., call-&gt;class-&gt;perf_probe, ...)</code>，即register probe <code>perf_trace_sched_switch</code>。</p>
<p>总之，perf使用tracepoint的方式，也是定义probe并register它。</p>
<h1 id="作为eBPF的event-source-5"><a href="#作为eBPF的event-source-5" class="headerlink" title="作为eBPF的event-source (5)"></a>作为eBPF的event-source (5)</h1><p>事先说明，eBPF是通过perf来使用tracepoint的，而没有定义自己的“ebpf probe”函数并register。魔法就在于perf probe函数<code>perf_trace_sched_switch</code>的最后一句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> notrace <span class="keyword">void</span></span><br><span class="line">perf_trace_sched_switch(<span class="keyword">void</span> *__data, <span class="keyword">bool</span> preempt, struct task_struct *prev, struct task_struct *next)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    perf_trace_run_bpf_submit(entry, __entry_size, rctx,</span><br><span class="line">                              event_call, __count, __regs,</span><br><span class="line">                              head, __task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要提交entry，但不一定提交到perf的ring buffer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># kernel/events/core.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perf_trace_run_bpf_submit</span><span class="params">(<span class="keyword">void</span> *raw_data, <span class="keyword">int</span> size, <span class="keyword">int</span> rctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct trace_event_call *call, u64 count,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct pt_regs *regs, struct hlist_head *head,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bpf_prog_array_valid(call)) &#123;</span><br><span class="line">                *(struct pt_regs **)raw_data = regs;</span><br><span class="line">                <span class="keyword">if</span> (!trace_call_bpf(call, raw_data) || hlist_empty(head)) &#123;</span><br><span class="line">                        perf_swevent_put_recursion_context(rctx);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        perf_tp_event(call-&gt;event.type, count, raw_data, size, regs, head,</span><br><span class="line">                      rctx, task);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(perf_trace_run_bpf_submit);</span><br></pre></td></tr></table></figure>

<p>当<code>bpf_prog_array_valid()</code>返回false时，才会调用<code>perf_tp_event()</code>提交到perf的ring buffer；这属于上一节的内容。</p>
<p>本节我们看<code>bpf_prog_array_valid()</code>为true时的情形。它什么时候返回true呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bpf_prog_array_valid</span><span class="params">(struct trace_event_call *call)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !!READ_ONCE(call-&gt;prog_array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>回顾第3.3节第3次展开的<code>struct trace_event_call</code>，里面就有<code>prog_array</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trace_event_call</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">        <span class="keyword">int</span>                             perf_refcount;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> __<span class="title">percpu</span>      *<span class="title">perf_events</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog_array</span> __<span class="title">rcu</span>     *<span class="title">prog_array</span>;</span>   <span class="comment">/*数组每个元素是一个eBPF program，最多BPF_TRACE_MAX_PROGS=64个*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>     (*perf_perm)(struct trace_event_call *,</span><br><span class="line">                             struct perf_event *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当syscall<code>ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd)</code>被调用时，经过<code>perf_event_set_bpf_prog</code>调用<code>perf_event_attach_bpf_prog</code>安装一个eBPF program (program之前已经被load到内核并返回了<code>prog_fd</code>，这里通过<code>prog_fd</code>指定该program)；见<code>kernel/events/core.c</code>(linux-5.10.161)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _perf_ioctl(struct perf_event *event, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">void</span> (*func)(struct perf_event *);</span><br><span class="line">        u32 flags = arg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> PERF_EVENT_IOC_SET_BPF:</span><br><span class="line">                <span class="keyword">return</span> perf_event_set_bpf_prog(event, arg);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">perf_event_set_bpf_prog</span><span class="params">(struct perf_event *event, u32 prog_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">        prog = bpf_prog_get(prog_fd);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        ret = perf_event_attach_bpf_prog(event, prog);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>perf_event_attach_bpf_prog</code>在<code>kernel/trace/bpf_trace.c</code>(linux-5.10.161)中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_TRACE_MAX_PROGS 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">perf_event_attach_bpf_prog</span><span class="params">(struct perf_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct bpf_prog *prog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog_array</span> *<span class="title">old_array</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog_array</span> *<span class="title">new_array</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret = -EEXIST;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;bpf_event_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event-&gt;prog)</span><br><span class="line">                <span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">        old_array = bpf_event_rcu_dereference(event-&gt;tp_event-&gt;prog_array);</span><br><span class="line">        <span class="keyword">if</span> (old_array &amp;&amp;</span><br><span class="line">            bpf_prog_array_length(old_array) &gt;= BPF_TRACE_MAX_PROGS) &#123;</span><br><span class="line">                ret = -E2BIG;</span><br><span class="line">                <span class="keyword">goto</span> unlock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = bpf_prog_array_copy(old_array, <span class="literal">NULL</span>, prog, &amp;new_array);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> unlock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set the new array to event-&gt;tp_event and set event-&gt;prog */</span></span><br><span class="line">        event-&gt;prog = prog;</span><br><span class="line">        rcu_assign_pointer(event-&gt;tp_event-&gt;prog_array, new_array);</span><br><span class="line">        bpf_prog_array_free(old_array);</span><br><span class="line"></span><br><span class="line">unlock:</span><br><span class="line">        mutex_unlock(&amp;bpf_event_mutex);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它看上去有点绕，其实是这样的：<code>event-&gt;tp_event</code>就是<code>struct trace_event_call</code>类型指针；如前所述，它有一个<code>prog_array</code>成员；<code>bpf_prog_array_valid()</code>就是判断这个成员。这里就是:</p>
<ul>
<li><code>old_array</code> = <code>event-&gt;tp_event-&gt;prog_array</code>; 原来可能为空，也可能不空；</li>
<li><code>new_array</code> = <code>old_array + prog</code>；<code>bpf_prog_array_copy</code>的原型是<code>bpf_prog_array_copy(old_array, exclude_prog, include_prog, new_array);</code></li>
<li><code>event-&gt;tp_event-&gt;prog_array = new_array</code>;</li>
</ul>
<p>所以，经过attach，<code>bpf_prog_array_valid()</code>就会返回true;</p>
<p>回到到前面<code>perf_trace_run_bpf_submit()</code>函数，当用户attach了eBPF program，就会通过<code>trace_call_bpf</code>执行program；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># kernel/events/core.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perf_trace_run_bpf_submit</span><span class="params">(<span class="keyword">void</span> *raw_data, <span class="keyword">int</span> size, <span class="keyword">int</span> rctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct trace_event_call *call, u64 count,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct pt_regs *regs, struct hlist_head *head,</span></span></span><br><span class="line"><span class="function"><span class="params">                               struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bpf_prog_array_valid(call)) &#123;</span><br><span class="line">                *(struct pt_regs **)raw_data = regs;</span><br><span class="line">                <span class="keyword">if</span> (!trace_call_bpf(call, raw_data) || hlist_empty(head)) &#123;</span><br><span class="line">                        perf_swevent_put_recursion_context(rctx);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        perf_tp_event(call-&gt;event.type, count, raw_data, size, regs, head,</span><br><span class="line">                      rctx, task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># kernel/trace/bpf_trace.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">trace_call_bpf</span><span class="params">(struct trace_event_call *call, <span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cant_sleep();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        ret = BPF_PROG_RUN_ARRAY_CHECK(call-&gt;prog_array, ctx, BPF_PROG_RUN);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span>/linux/bpf.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_PROG_RUN_ARRAY_CHECK(array, ctx, func)      \</span></span><br><span class="line">        __BPF_PROG_RUN_ARRAY(<span class="built_in">array</span>, ctx, func, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __BPF_PROG_RUN_ARRAY(array, ctx, func, check_non_null, set_cg_storage) \</span></span><br><span class="line">        (&#123;                                              \</span><br><span class="line">                struct bpf_prog_array_item *_item;      \</span><br><span class="line">                struct bpf_prog *_prog;                 \</span><br><span class="line">                struct bpf_prog_array *_array;          \</span><br><span class="line">                u32 _ret = <span class="number">1</span>;                           \</span><br><span class="line">                migrate_disable();                      \</span><br><span class="line">                rcu_read_lock();                        \</span><br><span class="line">                _array = rcu_dereference(<span class="built_in">array</span>);        \</span><br><span class="line">                <span class="keyword">if</span> (unlikely(check_non_null &amp;&amp; !_array))\</span><br><span class="line">                        <span class="keyword">goto</span> _out;                      \</span><br><span class="line">                _item = &amp;_array-&gt;items[<span class="number">0</span>];              \</span><br><span class="line">                <span class="keyword">while</span> ((_prog = READ_ONCE(_item-&gt;prog))) &#123;              \</span><br><span class="line">                        <span class="keyword">if</span> (!set_cg_storage) &#123;                  \</span><br><span class="line">                                _ret &amp;= func(_prog, ctx);       \</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;                                \</span><br><span class="line">                                <span class="keyword">if</span> (unlikely(bpf_cgroup_storage_set(_item-&gt;cgroup_storage)))    \</span><br><span class="line">                                        <span class="keyword">break</span>;                  \</span><br><span class="line">                                _ret &amp;= func(_prog, ctx);       \</span><br><span class="line">                                bpf_cgroup_storage_unset();     \</span><br><span class="line">                        &#125;                               \</span><br><span class="line">                        _item++;                        \</span><br><span class="line">                &#125;                                       \</span><br><span class="line">_out:                                                   \</span><br><span class="line">                rcu_read_unlock();                      \</span><br><span class="line">                migrate_enable();                       \</span><br><span class="line">                _ret;                                   \</span><br><span class="line">         &#125;)</span><br></pre></td></tr></table></figure>

<p>这里逐一执行eBPF program。</p>
<p>总接来说：eBPF使用tracepoint做event-source，绝大多数工作都是通过perf完成的，即probe函数做的那些事，分配entry并赋值等。只是最后不提交到perf的ring buffer里，而是触发eBPF program的执行(存储到eBPF的table/storage中?)。</p>
<h1 id="总结-6"><a href="#总结-6" class="headerlink" title="总结 (6)"></a>总结 (6)</h1><p>Linux tracepint是静态的事件源，内核代码中有很多<code>trace_##subsys_##event()</code>调用。这些调用就是hook，正常情况下是空的。若想使用它，就给它关联(注册)probe函数，这样当内核运行到hook处就会调用probe。本文以tracepoint为焦点，首先介绍了它的创建与使用，即通过<code>DECLARE_TRACE/DEFINE_TRACE</code>创建，通过<code>tracepoint_probe_register</code>注册probe来使用。其实这已经是完整的tracepoint了。只是使用起来有门槛。</p>
<p>为了方便使用，又把它作为ftrace以及perf的是event-source，这样使用者不必自己开发并注册probe函数，而是通过ftrace或者perf来使用它。内核代码中预置了ftrace以及perf版本的probe，使用者通过ftrace和perf的接口就可以注册并触发。宏<code>TRACE_EVENT</code>就是在调用<code>DECLARE_TRACE/DEFINE_TRACE</code>创建tracepoint之后，预置ftrace以及perf版本的probe函数(以及一些配套的数据结构)。在perf的基础上，eBPF也可以使用tracepoint。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>写的不错，有赏！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Yuanguo Huo 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Yuanguo Huo 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kernel/" rel="tag"># kernel</a>
              <a href="/tags/tracing/" rel="tag"># tracing</a>
              <a href="/tags/event-source/" rel="tag"># event-source</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/26/basic-paxos/" rel="prev" title="Basic Paxos">
      <i class="fa fa-chevron-left"></i> Basic Paxos
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/07/18/linux-tracing-ftrace/" rel="next" title="Linux Ftrace">
      Linux Ftrace <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          本站概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">1.</span> <span class="nav-text">概述 (1)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAtracepoint-2"><span class="nav-number">2.</span> <span class="nav-text">创建tracepoint (2)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BAftrace%E7%9A%84event-source-3"><span class="nav-number">3.</span> <span class="nav-text">作为ftrace的event-source (3)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TRACE-EVENT%E7%9A%84%E7%BB%93%E6%9E%84-3-1"><span class="nav-number">3.1.</span> <span class="nav-text">TRACE_EVENT的结构 (3.1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-3-2"><span class="nav-number">3.2.</span> <span class="nav-text">例子 (3.2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TRACE-EVENT%E7%9A%84%E5%AE%9E%E7%8E%B0-3-3"><span class="nav-number">3.3.</span> <span class="nav-text">TRACE_EVENT的实现 (3.3)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC1%E6%AC%A1%E5%B1%95%E5%BC%80-3-3-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">第1次展开 (3.3.1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC2%E6%AC%A1%E5%B1%95%E5%BC%80-3-3-2"><span class="nav-number">3.3.2.</span> <span class="nav-text">第2次展开 (3.3.2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%AE%8F-3-3-3"><span class="nav-number">3.3.3.</span> <span class="nav-text">高阶宏 (3.3.3)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC3%E6%AC%A1%E5%B1%95%E5%BC%80-3-3-4"><span class="nav-number">3.3.4.</span> <span class="nav-text">第3次展开 (3.3.4)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC4%E6%AC%A1%E5%B1%95%E5%BC%80-3-3-5"><span class="nav-number">3.3.5.</span> <span class="nav-text">第4次展开 (3.3.5)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC5%E6%AC%A1%E5%B1%95%E5%BC%80-3-3-6"><span class="nav-number">3.3.6.</span> <span class="nav-text">第5次展开 (3.3.6)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC6%E6%AC%A1%E5%B1%95%E5%BC%80-3-3-7"><span class="nav-number">3.3.7.</span> <span class="nav-text">第6次展开 (3.3.7)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC7%E6%AC%A1%E5%B1%95%E5%BC%80-3-3-8"><span class="nav-number">3.3.8.</span> <span class="nav-text">第7次展开 (3.3.8)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC8%E6%AC%A1%E5%B1%95%E5%BC%80-3-3-9"><span class="nav-number">3.3.9.</span> <span class="nav-text">第8次展开 (3.3.9)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC9%E6%AC%A1%E5%B1%95%E5%BC%80-3-3-10"><span class="nav-number">3.3.10.</span> <span class="nav-text">第9次展开 (3.3.10)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE-3-3-11"><span class="nav-number">3.3.11.</span> <span class="nav-text">回顾 (3.3.11)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ftrace-init-3-3-12"><span class="nav-number">3.3.12.</span> <span class="nav-text">ftrace init (3.3.12)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enable-event-3-3-13"><span class="nav-number">3.3.13.</span> <span class="nav-text">enable event (3.3.13)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-3-3-14"><span class="nav-number">3.3.14.</span> <span class="nav-text">小结 (3.3.14)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BAperf%E7%9A%84event-source-4"><span class="nav-number">4.</span> <span class="nav-text">作为perf的event-source (4)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BAeBPF%E7%9A%84event-source-5"><span class="nav-number">5.</span> <span class="nav-text">作为eBPF的event-source (5)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-number">6.</span> <span class="nav-text">总结 (6)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuanguo Huo"
      src="/images/me.gif">
  <p class="site-author-name" itemprop="name">Yuanguo Huo</p>
  <div class="site-description" itemprop="description">A little better than yesterday</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanguohuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanguohuo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanguo.h001@gmail.com" title="E-Mail → mailto:yuanguo.h001@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanguo Huo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"sKs2IrqwziD8hQqWqhcBdmxB-gzGzoHsz","app_key":"j2NAkBzz8pzcwkRlYdi87QEY","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'sKs2IrqwziD8hQqWqhcBdmxB-gzGzoHsz',
      appKey     : 'j2NAkBzz8pzcwkRlYdi87QEY',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

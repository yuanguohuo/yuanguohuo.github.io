<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="书接前文，本文介绍kvmtool的中断虚拟化。中断虚拟化是基于pci的capability机制实现的。">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟化入门笔记--kvmtool interrupt virtualization">
<meta property="og:url" content="http://yoursite.com/2024/08/11/virtualization-5-kvmtool-interrupt/index.html">
<meta property="og:site_name" content="Yuanguo&#39;s Blog">
<meta property="og:description" content="书接前文，本文介绍kvmtool的中断虚拟化。中断虚拟化是基于pci的capability机制实现的。">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2024/08/11/virtualization-5-kvmtool-interrupt/pci-device-in-view-of-guest.png">
<meta property="og:image" content="http://yoursite.com/2024/08/11/virtualization-5-kvmtool-interrupt/os-set-pci-dev-msix-table.png">
<meta property="og:image" content="http://yoursite.com/2024/08/11/virtualization-5-kvmtool-interrupt/build-msi-irq-routing-table.png">
<meta property="og:image" content="http://yoursite.com/2024/08/11/virtualization-5-kvmtool-interrupt/interrupt-and-pci-devices.png">
<meta property="article:published_time" content="2024-08-11T16:43:25.000Z">
<meta property="article:modified_time" content="2025-07-10T09:32:33.565Z">
<meta property="article:author" content="Yuanguo Huo">
<meta property="article:tag" content="virtualization">
<meta property="article:tag" content="kvm">
<meta property="article:tag" content="kvmtool">
<meta property="article:tag" content="interrupt">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2024/08/11/virtualization-5-kvmtool-interrupt/pci-device-in-view-of-guest.png">

<link rel="canonical" href="http://yoursite.com/2024/08/11/virtualization-5-kvmtool-interrupt/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>虚拟化入门笔记--kvmtool interrupt virtualization | Yuanguo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yuanguo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/08/11/virtualization-5-kvmtool-interrupt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.gif">
      <meta itemprop="name" content="Yuanguo Huo">
      <meta itemprop="description" content="A little better than yesterday">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanguo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          虚拟化入门笔记--kvmtool interrupt virtualization
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="Created: 2024-08-11 16:43:25" itemprop="dateCreated datePublished" datetime="2024-08-11T16:43:25+00:00">2024-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="Modified: 2025-07-10 09:32:33" itemprop="dateModified" datetime="2025-07-10T09:32:33+00:00">2025-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">所属分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kvm/" itemprop="url" rel="index"><span itemprop="name">kvm</span></a>
                </span>
            </span>

          
            <span id="/2024/08/11/virtualization-5-kvmtool-interrupt/" class="post-meta-item leancloud_visitors" data-flag-title="虚拟化入门笔记--kvmtool interrupt virtualization" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/11/virtualization-5-kvmtool-interrupt/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/11/virtualization-5-kvmtool-interrupt/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>书接<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/07/22/virtualization-4-kvmtool-pci/">前文</a>，本文介绍kvmtool的中断虚拟化。中断虚拟化是基于pci的capability机制实现的。</p>
<a id="more"></a>

<h1 id="x86中断回顾-1"><a href="#x86中断回顾-1" class="headerlink" title="x86中断回顾 (1)"></a>x86中断回顾 (1)</h1><h2 id="名词解释-1-1"><a href="#名词解释-1-1" class="headerlink" title="名词解释 (1.1)"></a>名词解释 (1.1)</h2><ul>
<li>PIC:  Programmable Interrupt Controller, 在x86/x64架构下，特指master-slave级联的2个8259A；</li>
<li>APIC: Advanced PIC (Advanced Programmable Interrupt Controller)；每个CPU有一个Local-APIC，系统有一个或者多个IO-APIC (一般是一个)；</li>
<li>ACPI: Advanced Configuration and Power Interface. 是一个specification，包含很多东西，其中一个是使用GSI来进行interrupt routing；</li>
<li>IRQ: PIC/APIC中的概念，就是中断控制器引脚的编号；PIC有15个, IRQ0, IRQ1, IRQ3, …, IRQ15 (注意IRQ2用于级联)；IO-APIC有24个, IRQ0, IRQ1…, IRQ23；</li>
<li>Interrupt vector number: 中断向量，Intel的叫法，简称INT；就是指向IDT(中断描述符表)中的一个条目的index；</li>
<li>System vector number: GSI number. 系统中每个中断源唯一的中断编号，所以数量比较大，比如kvm默认支持1024个(虚拟的)GSI；</li>
</ul>
<h2 id="如何产生IRQ-1-2"><a href="#如何产生IRQ-1-2" class="headerlink" title="如何产生IRQ (1.2)"></a>如何产生IRQ (1.2)</h2><p>The two standard interrupt controllers on an x86 system are:</p>
<ul>
<li>The 8259A PIC：There are always two PICs, at standard IO addresses, each with eight input pins (IR 0-7). One PIC is the master and handles IRQ 0-7. The other is the slave and handles IRQ 8-15, its output goes to IR2 of the master. (slave的输出连接到master的IR2引脚上).</li>
<li>The IO APIC (Do not confuse the IO APIC with the LAPIC, 即Local-APIC, CPU core内集成的APIC)：There can be one or multiple IO APICs, all mapped at memory addresses, each with a variable number of input pins INTINx. Usually, one of the IO APIC is wired and configured to emulate the PICs, INTIN0-15 are mapped to IRQ0-15 but this is not a requirement.</li>
</ul>
<p>这两种是传统的方式，下面会看到还有第三种，即MSI (Message Signaled Interrupt)；</p>
<h2 id="IRQ映射到INT-1-3"><a href="#IRQ映射到INT-1-3" class="headerlink" title="IRQ映射到INT (1.3)"></a>IRQ映射到INT (1.3)</h2><p>The interrupt controllers are configured to map an IRQ number into a vector number. Once one knows the IRQ number it is easy to get the INT number, the OS generally can easily make a table for that purpose since it is well known how the interrupt controllers are connected to the CPUs.</p>
<p>至此有两级关系：IRQ =&gt; INT (interrupt vector)</p>
<h2 id="如何给device关联一个IRQ-interrupt-routing-GSI-1-4"><a href="#如何给device关联一个IRQ-interrupt-routing-GSI-1-4" class="headerlink" title="如何给device关联一个IRQ (interrupt routing, GSI) (1.4)"></a>如何给device关联一个IRQ (interrupt routing, GSI) (1.4)</h2><p>Associating an IRQ to a device (a process known as interrupt routing) is very complex because it requires a knowledge of how devices are connected. The ACPI specification (注意ACPI不是APIC) use GSIs (Global System Interrupt) to simplify this aspect. 忽略细节，先给设备关联一个GSI，再把GSI映射到IRQ (IRQ再映射到INT).</p>
<h2 id="GSI映射到IRQ-1-5"><a href="#GSI映射到IRQ-1-5" class="headerlink" title="GSI映射到IRQ (1.5)"></a>GSI映射到IRQ (1.5)</h2><p>In the end, GSIs (or in ACPI words, system vectors) must be mapped to IRQs</p>
<ul>
<li>8259A PIC: the GSIs map directly to ISA IRQs. Thus, IRQ 0 is GSI 0, etc.</li>
<li>IO APIC: Each IO APIC is assigned a base GSI by the BIOS. Each input pin on the IO APIC is mapped to a GSI number by adding the pin number (zero-based) to the base GSI. Thus, if an IO APIC has a base GSI of N, pin 0 on that IO APIC has a GSI of N, pin 1 has a GSI of N + 1, etc. The IO APIC with a base GSI of 0 maps the ISA IRQs onto its first 16 input pins.</li>
</ul>
<p>所以总共有三级映射关系: GSI (system vector) =&gt; IRQ =&gt; INT (interrupt vector)。<br>注意：system vector(GSI)不要和interrupt vector(INT) 搞混淆。</p>
<h2 id="Message-Signaled-Interrupts-MSI-1-6"><a href="#Message-Signaled-Interrupts-MSI-1-6" class="headerlink" title="Message Signaled Interrupts (MSI) (1.6)"></a>Message Signaled Interrupts (MSI) (1.6)</h2><p>上面说的一切都是传统中断，而MSI是一种平替传统中断的新中断机制… The 8259A PIC was the first generation controller, the IO APIC the second, and MSIs are the third.</p>
<p>Traditionally, a device has an interrupt line (pin) which it asserts when it wants to signal an interrupt to the host processing environment. This traditional form of interrupt signalling is an out-of-band form of control signalling since it uses a dedicated path to send such control information, separately from the main data path.</p>
<p>MSI replaces those dedicated interrupt lines with in-band signalling, by exchanging special messages that indicate interrupts through the main data path. In particular, MSI allows the device to write a small amount of interrupt-describing data to a special memory-mapped I/O address (集成于CPU core内的Local-APIC的寄存器，被map到特定的memory address), and the chipset then delivers the corresponding interrupt to a processor.</p>
<p>On Intel x86 systems, the Local-APIC (LAPIC) must be enabled for the PCI (and PCIe) MSI/MSI-X to work, even on uniprocessor (single core) systems. In these systems, MSIs are handled by writing the interrupt vector directly into the LAPIC of the processor/core that needs to service the interrupt.</p>
<p>As an example, PCI Express does not have separate interrupt pins at all; instead, it uses special in-band messages to allow pin assertion or deassertion to be emulated.</p>
<p>一个PCIe设备通常是多队列的，每个队列可以触发一个不同的中断(不同GSI)。并且，不同的中断通过affinity绑定不同的CPU处理，就实现了负载均衡。</p>
<h2 id="How-MSI-Works-1-7"><a href="#How-MSI-Works-1-7" class="headerlink" title="How MSI Works (1.7)"></a>How MSI Works (1.7)</h2><p>There is no interrupt PIN for PCIe interrupt. When device wants to raise an interrupt, an interrupt message is sent to host via inband PCIe channels. The interrupt message is a write command, destination of the write is to the host memory specified by the HOST.</p>
<p>The host specifies the destination address of the interrupt message at the MSI-X table. I believe the MSI-X table is setup by the OS boot up normally. 在后文将看到，host往pci设备的某个bar region写入MSI-X table. MSI-X table告诉pci设备：要触发哪个中断就往哪个地址写什么样的数据。</p>
<p>On X86 platform, the interrupt message is written to LAPIC (Local component of Advanced Programmable Interrupt Controller), usually integrated into the processor itself. 即前面说的：CPU core内集成的Local-APIC的寄存器，被map到特定memory address. On ARM platform, the interrupt message is written to ARM Generic Interrupt Controller(GIC), GIC’s LPI (Locality-specific Peripheral Interrupts) and ITS(Interrupt Translation Service) support MSI-X messages.</p>
<h2 id="MSI和MSI-X-1-8"><a href="#MSI和MSI-X-1-8" class="headerlink" title="MSI和MSI-X (1.8)"></a>MSI和MSI-X (1.8)</h2><p>MSI和MSI-X是两个不同的版本，引用维基百科：</p>
<ul>
<li><p>MSI：MSI (first defined in PCI 2.2) permits a device to allocate 1, 2, 4, 8, 16 or 32 interrupts(所以一个设备可以实现多队列). The device is programmed with an address to write to (this address is generally a control register in an interrupt controller，即Local-APIC的寄存器), and a 16-bit data word to identify it. The interrupt number is added to the data word to identify the interrupt. Some platforms such as Windows do not use all 32 interrupts but only use up to 16 interrupts.</p>
</li>
<li><p>MSI-X：MSI-X (first defined in PCI 3.0) permits a device to allocate up to 2048 interrupts. The single address used by original MSI was found to be restrictive for some architectures. In particular, it made it difficult to target individual interrupts to different processors, which is helpful in some high-speed networking applications. MSI-X allows a larger number of interrupts and gives each one a separate target address and data word. Devices with MSI-X do not necessarily support 2048 interrupts. Optional features in MSI (64-bit addressing and interrupt masking) are also mandatory with MSI-X.</p>
</li>
</ul>
<p>注意一个区别：</p>
<ul>
<li>对于MSI，data是用于identify PCI设备的数字，是系统分配的————系统对PCI设备编程，告诉PCI设备这个数字。PCI设备发中断时，拿data加上interrupt number(应该就是interrupt vector)得到一个新的数字，然后往给定地址上写这个新数字。</li>
<li>对于MSI-X，data是系统分配的，直接对应一个中断；PCI设备发中断时，直接往给定地址写这个数字。这一点在kvmtool实验中可以证实。</li>
</ul>
<p>下文措辞上不区分MSI和MSI-X，一般说的都是它们共同特征；kvmtool实现的是MSI-X。</p>
<h1 id="中断虚拟化-2"><a href="#中断虚拟化-2" class="headerlink" title="中断虚拟化 (2)"></a>中断虚拟化 (2)</h1><p>首先说明，中断虚拟化的工作主要是由kvm内核模块完成的，而不是VMM(kvmtool或qemu)。具体到kvmtool，它的主要工作是构造这么一张表(叫做中断路由表)：</p>
<table>
<thead>
<tr>
<th>gsi</th>
<th>type</th>
<th>u.irqchip.irqchip</th>
<th>u.irqchip.pin</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_MASTER(Master-8259A)</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_MASTER(Master-8259A)</td>
<td>1</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_MASTER(Master-8259A)</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_MASTER(Master-8259A)</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_MASTER(Master-8259A)</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_MASTER(Master-8259A)</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_MASTER(Master-8259A)</td>
<td>7</td>
</tr>
<tr>
<td>8</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_SLAVE(Slave-8259A)</td>
<td>0</td>
</tr>
<tr>
<td>9</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_SLAVE(Slave-8259A)</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_SLAVE(Slave-8259A)</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_SLAVE(Slave-8259A)</td>
<td>3</td>
</tr>
<tr>
<td>12</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_SLAVE(Slave-8259A)</td>
<td>4</td>
</tr>
<tr>
<td>13</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_SLAVE(Slave-8259A)</td>
<td>5</td>
</tr>
<tr>
<td>14</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_SLAVE(Slave-8259A)</td>
<td>6</td>
</tr>
<tr>
<td>15</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_SLAVE(Slave-8259A)</td>
<td>7</td>
</tr>
<tr>
<td>0</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>1</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>3</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>7</td>
</tr>
<tr>
<td>8</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>8</td>
</tr>
<tr>
<td>9</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>9</td>
</tr>
<tr>
<td>10</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>10</td>
</tr>
<tr>
<td>11</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>11</td>
</tr>
<tr>
<td>12</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>12</td>
</tr>
<tr>
<td>13</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>13</td>
</tr>
<tr>
<td>14</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>14</td>
</tr>
<tr>
<td>15</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>15</td>
</tr>
<tr>
<td>16</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>16</td>
</tr>
<tr>
<td>17</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>17</td>
</tr>
<tr>
<td>18</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>18</td>
</tr>
<tr>
<td>19</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>19</td>
</tr>
<tr>
<td>20</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>20</td>
</tr>
<tr>
<td>21</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>21</td>
</tr>
<tr>
<td>22</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>22</td>
</tr>
<tr>
<td>23</td>
<td>KVM_IRQ_ROUTING_IRQCHIP</td>
<td>IRQCHIP_IOAPIC</td>
<td>23</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>gsi</th>
<th>type</th>
<th>u.msi.address_hi</th>
<th>u.msi.address_lo</th>
<th>u.msi.data</th>
</tr>
</thead>
<tbody><tr>
<td>24</td>
<td>KVM_IRQ_ROUTING_MSI</td>
<td>0x0</td>
<td>0xfee00000</td>
<td>0x4022</td>
</tr>
<tr>
<td>25</td>
<td>KVM_IRQ_ROUTING_MSI</td>
<td>0x0</td>
<td>0xfee1f000</td>
<td>0x4021</td>
</tr>
<tr>
<td>26</td>
<td>KVM_IRQ_ROUTING_MSI</td>
<td>0x0</td>
<td>0xfee01000</td>
<td>0x4022</td>
</tr>
<tr>
<td>27</td>
<td>KVM_IRQ_ROUTING_MSI</td>
<td>0x0</td>
<td>0xfee02000</td>
<td>0x4022</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li>这张表有2种不同的结构(其实还不止2种)，这是通过C语言的union实现的；</li>
<li>上半部分是模拟传统的中断方式，即PIC或者IO-APIC：一个gsi号最终被map到一个芯片的引脚上，也就得到了IRQ号：例如Master-8259A的pin0是IRQ0，pin1是IRQ1，pin2没用，pin3是IRQ3，……；Slave-8259A的pin0是IRQ8，pin1是IRQ9，……，pin7是IRQ15；IO-APIC的pin0没用，pin1是IRQ1，pin2是IRQ0，pin3是IRQ3，……，pin23是IRQ23；</li>
<li>下半部分是模拟MSI中断方式：一个gsi号最终被map到addr和data；若要触发此中断，就往对应的addr写对应的data；</li>
</ul>
<p>有一点要注意：在这张表中，gsi不是唯一的，但这并不会引起混淆：要触发某个gsi对应的中断，可能由PIC芯片处理，也可能由IO-APIC处理，到时候逐一调用，哪个能处理哪个处理。应该是连接方式决定的，一个硬件要是模拟连在PIC上就由PIC处理，要是模拟连在IO-APIC上就由IO-APIC处理。</p>
<p>中断路由表是kvmtool在内存中构造的，然后后通过如下接口设置到kvm内核模块:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(vm_fd, KVM_SET_GSI_ROUTING, 中断路由表地址);</span><br></pre></td></tr></table></figure>

<p>有了中断路由表，kvm内核模块就可以模拟中断机制。如前所述，kvm内核模块完成主要的中断模拟工作：</p>
<ul>
<li>对于irqchip方式，kvm内核模块模拟芯片(8259A或者IOAPIC)行为，更新芯片的相关寄存器，并唤醒guest vcpu，注入中断；</li>
<li>对于msi方式，kvm内核模块往guest的内存addr写data；内存addr映射的是vcpu的Local-APIC的寄存器；</li>
</ul>
<p>Kvmtool如何触发中断呢？请求kvm内核模块来触发(注：在kvmtool中device向guest发中断用signal一词，guest向device发通知用notify一词)：</p>
<ul>
<li>对于irqchip方式：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(kvm-&gt;vm_fd, KVM_IRQ_LINE, &#123;.irq=gsi&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>对于msi方式:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(kvm-&gt;vm_fd, KVM_SIGNAL_MSI, &#123;.address_lo=addr_lo .address_hi=addr_hi, .data=data&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="构建IRQCHIP中断路由表-3"><a href="#构建IRQCHIP中断路由表-3" class="headerlink" title="构建IRQCHIP中断路由表 (3)"></a>构建IRQCHIP中断路由表 (3)</h1><p>这部分非常直接，代码如下，结果就是第2节中断路由表的上半部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">irq__add_routing</span><span class="params">(u32 gsi, u32 type, u32 irqchip, u32 pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = irq__allocate_routing_entry();</span><br><span class="line">    <span class="keyword">if</span> (r)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    irq_routing-&gt;entries[irq_routing-&gt;nr++] =</span><br><span class="line">        (struct kvm_irq_routing_entry) &#123;</span><br><span class="line">            .gsi = gsi,</span><br><span class="line">            .type = type,</span><br><span class="line">            .u.irqchip.irqchip = irqchip,</span><br><span class="line">            .u.irqchip.pin = pin,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">irq__init</span><span class="params">(struct kvm *kvm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hook first 8 GSIs to master IRQCHIP */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">2</span>)</span><br><span class="line">            irq__add_routing(i, KVM_IRQ_ROUTING_IRQCHIP, IRQCHIP_MASTER, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hook next 8 GSIs to slave IRQCHIP */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        irq__add_routing(i, KVM_IRQ_ROUTING_IRQCHIP, IRQCHIP_SLAVE, i - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last but not least, IOAPIC */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            irq__add_routing(i, KVM_IRQ_ROUTING_IRQCHIP, IRQCHIP_IOAPIC, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">2</span>)</span><br><span class="line">            irq__add_routing(i, KVM_IRQ_ROUTING_IRQCHIP, IRQCHIP_IOAPIC, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = ioctl(kvm-&gt;vm_fd, KVM_SET_GSI_ROUTING, irq_routing);</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        <span class="built_in">free</span>(irq_routing);</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* next_gsi=24；所以MSI的GSI从24开始 */</span></span><br><span class="line">    next_gsi = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="构建MSI中断路由表-4"><a href="#构建MSI中断路由表-4" class="headerlink" title="构建MSI中断路由表 (4)"></a>构建MSI中断路由表 (4)</h1><h2 id="PCI的Capability-List-4-1"><a href="#PCI的Capability-List-4-1" class="headerlink" title="PCI的Capability-List (4.1)"></a>PCI的Capability-List (4.1)</h2><p>前一篇<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/07/22/virtualization-4-kvmtool-pci/">pci virtualization</a>介绍了PCI的configuration space，并着重介绍了64字节的header部分，分为Bridge和Non-Bridge两种类型。这是所有PCI设备的common部分。为了支持设备的多样性，configuration space中还包括一些扩展空间，即Capability-List. PCI是192字节(加上64字节的header一共是256字节)，PCIe是4032字节(加上64字节header是4096字节)，它们都是设备的寄存器。</p>
<p>在这块空间中，有多个capability，每个capability有各自的Id，各自不同的描述结构。并且它们构成一个链表：每个capability都有next指针(下一个capability在configuration space中的偏移)。Header中的Status字段能够表示是否启用了Capability-List，若启用的话Cap.Pointer字段指向链表的头。</p>
<p>系统初始化时enumerate PCI设备，并读取它们的configuration space，然后就知道每个PCI设备是否启用了Capability-List。若启用了，再读取或者写入capability的配置：系统和设备配合完成capability的初始化工作。</p>
<p>MSI中断就是通过Capability实现的。</p>
<h2 id="MSI-Capability-4-2"><a href="#MSI-Capability-4-2" class="headerlink" title="MSI-Capability (4.2)"></a>MSI-Capability (4.2)</h2><p>MSI-Capability的ID是<code>PCI_CAP_ID_MSIX</code>(即0x11)；</p>
<p>若PCI设备启用了Capability-List，它应该在它的configuration space中做以下设置:</p>
<ul>
<li>Header.Status设置特定的bit(<code>PCI_STATUS_CAP_LIST</code>，即0x10),表示启用了Capability-List；</li>
<li>Header.Cap.Pointer指向Capability-List链表的头；</li>
</ul>
<p>MSI-Capability的描述结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msix_cap</span> &#123;</span></span><br><span class="line">    u8 cap;</span><br><span class="line">    u8 next;</span><br><span class="line">    u16 ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BAR Indicator register，简称BIR，位于PCIe device的configuration space的capability中(不是header中)；</span></span><br><span class="line">    <span class="comment">//  - 最低3位表示哪个BAR的region用于存table；</span></span><br><span class="line">    <span class="comment">//  - 高29位表示table在BAR-region中的offset;</span></span><br><span class="line">    u32 table_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BAR Indicator register，简称BIR，位于PCIe device的configuration space的capability中(不是header中)；</span></span><br><span class="line">    <span class="comment">//  - 最低3位表示哪个BAR的region用于存PBA；</span></span><br><span class="line">    <span class="comment">//  - 高29位表示PBA在BAR-region中的offset;</span></span><br><span class="line">    <span class="comment">//PBA: Pending Bit Array, one bit per vector</span></span><br><span class="line">    u32 pba_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>若PCI设备启用了MSI-Capability，它还应该在它的configuration space中做以下设置:</p>
<ul>
<li>MSI-Capability在链表中(我们记作msix)，且msix.cap=PCI_CAP_ID_MSIX；</li>
<li>msix.ctrl: 设备的最大common-queue数，不包括configure-queue；每个queue对应一个gsi，所以设备最多占msix.ctrl+1个gsi；</li>
<li>msix.table_offset：低3位表示msix-table在哪个BAR中(0到5)；高29位表示msix-table在那个BAR-region中的offset；msix-table下面细说；</li>
<li>msix.pba_offset：低3位表示PBA(Pending Bit Array)在哪个BAR中(0到5)；高29位表示PBA在那个BAR-region中的offset；</li>
</ul>
<p>就是说，一个PCI设备可以触发多个中断(gsi不同，对应的IRQ不同，最终的INT也不同)：每个common-queue一个，外加configure-queue一个，共msix.ctrl+1个。前文说，触发MSI中断就是往给定的addr写入给定的data，所以一个PCI设备就有多个addr:data组合。这些addr:data构成一个表，就是msix-table；表项的数量也就是msix.ctrl+1。可想而知，addr:data是系统决定的，而不是PCI设备决定的，所以msix-table应该由系统OS或者BIOS来填写。PCI设备在msix.table_offset中设置的是表的地址(哪个BAR-region的哪个偏移)，且在msix.ctrl中设置了数量；系统读到它们之后，就知道往哪里写msix-table表项，以及写多少个。表项的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msi_msg</span> &#123;</span></span><br><span class="line">    u32    address_lo;    <span class="comment">/* low 32 bits of msi message address */</span></span><br><span class="line">    u32    address_hi;    <span class="comment">/* high 32 bits of msi message address */</span></span><br><span class="line">    u32    data;        <span class="comment">/* 16 bits of msi message data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个中断有一个bit来表示是否有pending，所以也构成一个array，叫做PBA (Pending Bit Array)，数量也是msix.ctrl+1。设备在msix.pba_offset中设置PBA的地址(哪个BAR-region的哪个偏移)；系统读到它之后，就知道把pending bit设置到哪里。</p>
<p>另外：msix-table和PBA可以放在同一个BAR-region中，也可以放在不同的BAR-region中，这是设备厂商的自由，都符合PCI协议。Kvmtool模拟的设备放在同一个BAR-region中，且固定为BAR-2。</p>
<p>对于真实的PCI设备，系统IO/BIOS和PCI交换配置，完成了MSI-Capability的初始化。对于kvmtool中的虚拟设备也是一样，guest IO/BIOS和PCI交换配置，最终生成中断路由表中的条目。</p>
<h2 id="kvmtool的实现-4-3"><a href="#kvmtool的实现-4-3" class="headerlink" title="kvmtool的实现 (4.3)"></a>kvmtool的实现 (4.3)</h2><h3 id="启用capability-msix-4-3-1"><a href="#启用capability-msix-4-3-1" class="headerlink" title="启用capability msix (4.3.1)"></a>启用capability msix (4.3.1)</h3><p>kvmtool/virtio/pci.c : virtio_pci__init() 每个PCI设备都由本函数初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vpci-&gt;pci_hdr = (struct pci_device_header) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置支持Capability List; PCI_STATUS_CAP_LIST=0x10.</span></span><br><span class="line">    .status            = cpu_to_le16(PCI_STATUS_CAP_LIST),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.capabilities=64. Capability List的头在第64字节处，即第一个capability是msix;</span></span><br><span class="line">    .capabilities        = PCI_CAP_OFF(&amp;vpci-&gt;pci_hdr, msix),</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看kvmtool中模拟的PCI configuration space，capability msix是不是在第64字节处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_device_header</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Configuration space, as seen by the guest */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            u16        vendor_id;</span><br><span class="line">            u16        device_id;</span><br><span class="line">            u16        command;</span><br><span class="line">            u16        status;</span><br><span class="line">            u8        revision_id;</span><br><span class="line">            u8        <span class="class"><span class="keyword">class</span>[3];</span></span><br><span class="line">            u8        cacheline_size;</span><br><span class="line">            u8        latency_timer;</span><br><span class="line">            u8        header_type;</span><br><span class="line">            u8        bist;</span><br><span class="line">            u32        bar[<span class="number">6</span>];</span><br><span class="line">            u32        card_bus;</span><br><span class="line">            u16        subsys_vendor_id;</span><br><span class="line">            u16        subsys_id;</span><br><span class="line">            u32        exp_rom_bar;</span><br><span class="line">            u8        capabilities;</span><br><span class="line">            u8        reserved1[<span class="number">3</span>];</span><br><span class="line">            u32        reserved2;</span><br><span class="line">            u8        irq_line;</span><br><span class="line">            u8        irq_pin;</span><br><span class="line">            u8        min_gnt;</span><br><span class="line">            u8        max_lat;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//上面一共是64字节，也就是PCI的标准header；下面是扩展区，一般用于存capability list;</span></span><br><span class="line">            <span class="comment">//第一个capability是MSI-X;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">msix_cap</span> <span class="title">msix</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Used only by architectures which support PCIE */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pci_exp_cap</span> <span class="title">pci_exp</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">virtio_caps</span> <span class="title">virtio</span>;</span></span><br><span class="line">        &#125; __attribute__((packed));</span><br><span class="line">        <span class="comment">/* Pad to PCI config space size */</span></span><br><span class="line">        u8    __pad[PCI_DEV_CFG_SIZE];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>果然，capability msix就是在第64字节处。看它的初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vpci-&gt;pci_hdr.msix.cap = PCI_CAP_ID_MSIX;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VIRTIO_NR_MSIX=33(32个common-queue, 1个configure-queue)，所以msix.ctrl = 32，表示32个common-queue;</span></span><br><span class="line">vpci-&gt;pci_hdr.msix.ctrl = cpu_to_le16(VIRTIO_NR_MSIX - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//msix.table_offset = 2；</span></span><br><span class="line"><span class="comment">//   低3位是2:  表示msix-table被map到BAR-2的region；</span></span><br><span class="line"><span class="comment">//   高29位是0: 表示msix-table在BAR-2 region中的偏移是0；</span></span><br><span class="line">vpci-&gt;pci_hdr.msix.table_offset = cpu_to_le32(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//msix.pba_offset = 2 | VIRTIO_MSIX_TABLE_SIZE </span></span><br><span class="line"><span class="comment">//   低3位是2:  表示PBA被map到BAR-2的region；</span></span><br><span class="line"><span class="comment">//   高29位是VIRTIO_MSIX_TABLE_SIZE: 表示PBA紧挨着msix-table;</span></span><br><span class="line">vpci-&gt;pci_hdr.msix.pba_offset = cpu_to_le32(<span class="number">2</span> | VIRTIO_MSIX_TABLE_SIZE);</span><br></pre></td></tr></table></figure>

<p>对于一个给定的PCI设备，guest系统在enumerate到它之后，就会从它的configuration space读到上面的配置。然后在guest眼中，它看到：</p>
<p><img src="pci-device-in-view-of-guest.png" alt="figure1"></p>
<div style="text-align: center;"><em>图1: 从guest的角度看PCI设备</em></div>


<p>在kvmtool的实现中，是用内存空间来模拟msix-table和pba的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_header</span> <span class="title">pci_hdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_header</span>    <span class="title">dev_hdr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    u64                    msix_pba;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msix_table</span>    <span class="title">msix_table</span>[<span class="title">VIRTIO_PCI_MAX_VQ</span> + <span class="title">VIRTIO_PCI_MAX_CONFIG</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="对PCI设备编程设置PCI设备的msix-table-4-3-2"><a href="#对PCI设备编程设置PCI设备的msix-table-4-3-2" class="headerlink" title="对PCI设备编程设置PCI设备的msix table (4.3.2)"></a>对PCI设备编程设置PCI设备的msix table (4.3.2)</h3><p>当guest读写BAR-region(这里特指写msix-table)时就会vmexit，kvm内核模块自己处理不了，就会转交给VMM(这里特指kvmtool)；kvmtool对每个BAR-region注册过不同的callback函数，具体到BAR-2就是<code>virtio_pci__msix_mmio_callback()</code>函数。所以guest系统写msix-table，kvmtool就触发<code>virtio_pci__msix_mmio_callback()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">virtio_pci__msix_mmio_callback(...)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    vecnum &#x3D; offset &#x2F; sizeof(struct msix_table);</span><br><span class="line">    offset &#x3D; offset % sizeof(struct msix_table);</span><br><span class="line"></span><br><span class="line">    if (!is_write) &#123;</span><br><span class="line">        memcpy(data, (void *)&amp;table[vecnum] + offset, len);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;更新msix-table中的给定entry</span><br><span class="line">    memcpy((void *)&amp;table[vecnum] + offset, data, len);</span><br><span class="line"></span><br><span class="line">    update_msix_map(...)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;这个时候，PCI设备的vector都还没确定: virtio_pci结构体的config_vector, vq_vector[...]都是0xffff(VIRTIO_MSI_NO_VECTOR)</span><br><span class="line">        &#x2F;&#x2F;irq__update_msix_route()不会被调用(后文会看到它被调用)；</span><br><span class="line">        &#x2F;&#x2F;所以这时update_msix_map()函数do nothing；</span><br><span class="line">        irq__update_msix_route(...)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;更新中断路由表irq_routing的给定entry</span><br><span class="line">               entry &#x3D; &amp;irq_routing-&gt;entries[i].u.msi;</span><br><span class="line">               changed  &#x3D; update_data(&amp;entry-&gt;address_hi, msg-&gt;address_hi);</span><br><span class="line">               changed |&#x3D; update_data(&amp;entry-&gt;address_lo, msg-&gt;address_lo);</span><br><span class="line">               changed |&#x3D; update_data(&amp;entry-&gt;data, msg-&gt;data);</span><br><span class="line"></span><br><span class="line">            irq__update_msix_routes()</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;把更新过的中断路由表告诉kvm内核模块</span><br><span class="line">                   return ioctl(kvm-&gt;vm_fd, KVM_SET_GSI_ROUTING, irq_routing);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就模拟了系统(guest)对PCI设备编程：设置msix-table；</p>
<p><img src="os-set-pci-dev-msix-table.png" alt="figure2"></p>
<div style="text-align: center;"><em>图2: 系统设置PCI设备的msix-table</em></div>

<h3 id="构建中断路由表并同步给kvm-4-3-3"><a href="#构建中断路由表并同步给kvm-4-3-3" class="headerlink" title="构建中断路由表并同步给kvm (4.3.3)"></a>构建中断路由表并同步给kvm (4.3.3)</h3><p>设置好msix-table之后，系统(guest)为queue配置中断。Queue可以分为common-queue和config-queue。Kvmtool中一个PCI设备最多可以使用32个common-queue，实际上可以不启用这么多。配置过程是：</p>
<ul>
<li>guest选择一个common-queue；kvmtool记下被选择的common-queue号；</li>
<li>guest设置被选择的common-queue的size；没看到实际作用，好多设备实现一个空操作。猜测：虚拟环境下，virt-queue有一个大小；vhost设备poll virt-queue以获取请求并处理；若vhost设备慢了，导致virt-queue堆积满(即达到size)，就会导致vmexit。所以这个值对VMM来说没有什么作用。</li>
<li>guest设置被选择的common-queue的中断；kvmtool为它分配gsi，添加中断路由表项，并告知kvm内核模块更新中断路由表；</li>
<li>guest发送被选择的common-queue的vring的地址给device；见<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/08/31/virtualization-6-kvmtool-virtio/">virtio设备</a>第3节；</li>
<li>guest启用被选择的common-queue；见<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/08/31/virtualization-6-kvmtool-virtio/">virtio设备</a>第4.1.2小节；</li>
</ul>
<p>Configure-queue和common-queue类似，但不用选择，因为它通过一个特殊的操作VIRTIO_PCI_COMMON_MSIX来配置；而所有common-queue共用VIRTIO_PCI_COMMON_Q_MSIX操作，所以先要选择一个common-queue，配置好一个之后再选择下一个。</p>
<p>Guest系统通过write BAR-1的region来完成上述配置；BAR-1对应的callback是<code>virtio_pci_modern__io_mmio_callback</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">virtio_pci_modern__io_mmio_callback(...)</span><br><span class="line">&#123;</span><br><span class="line">    virtio_pci_access(...)</span><br><span class="line">    &#123;</span><br><span class="line">        virtio_pci__common_write(...)</span><br><span class="line">        &#123;</span><br><span class="line">            switch (offset - VPCI_CFG_COMMON_START) &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;设置configure-queue的中断</span><br><span class="line">                case VIRTIO_PCI_COMMON_MSIX:</span><br><span class="line">                    &#x2F;&#x2F;vec是msix-table中的索引号，例如configure-queue的vec一般为0，表示configure-queue的中断路由信息是msix-table[0]；它在前面已经被设置。</span><br><span class="line">                    vec &#x3D; vpci-&gt;config_vector &#x3D; ioport__read16(data);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;gsi一般从24开始分配(0-23被irqchip占用)，各个PCI设备，各个queue(包括configure-queue)都不重合</span><br><span class="line">                    gsi &#x3D; virtio_pci__add_msix_route(vpci, vec)</span><br><span class="line">                          &#123;</span><br><span class="line">                              irq__add_msix_route()</span><br><span class="line">                              &#123;</span><br><span class="line">                                  &#x2F;&#x2F;分配中断路由表的entry；</span><br><span class="line">                                  irq__allocate_routing_entry();</span><br><span class="line"></span><br><span class="line">                                  &#x2F;&#x2F;分配gsi；即全局变量next_gsi的当前值；每次递增1；</span><br><span class="line"></span><br><span class="line">                                  &#x2F;&#x2F;初始化中断路由表的entry；</span><br><span class="line">                                  &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                  irq__update_msix_routes()</span><br><span class="line">                                  &#123;</span><br><span class="line">                                      &#x2F;&#x2F;将更新过的中断路由表同步给kvm内核模块</span><br><span class="line">                                      return ioctl(kvm-&gt;vm_fd, KVM_SET_GSI_ROUTING, irq_routing);</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                    if (gsi &lt; 0)</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                    vpci-&gt;config_gsi &#x3D; gsi;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; case ... </span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;下面4个操作配合起来，设置一个common-queue的中断；</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;操作1: 选择一个common-queue；后面三个操作都是针对这个queue的；</span><br><span class="line">                case VIRTIO_PCI_COMMON_Q_SELECT:</span><br><span class="line">                    val &#x3D; ioport__read16(data);</span><br><span class="line">                    if (val &gt;&#x3D; (u32)vdev-&gt;ops-&gt;get_vq_count(vpci-&gt;kvm, vpci-&gt;dev))</span><br><span class="line">                        pr_warning(&quot;invalid vq number %u&quot;, val);</span><br><span class="line">                    else</span><br><span class="line">                        vpci-&gt;queue_selector &#x3D; val;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;操作2：设置common-queue size;</span><br><span class="line">                case VIRTIO_PCI_COMMON_Q_SIZE:</span><br><span class="line">                    vdev-&gt;ops-&gt;set_size_vq(vpci-&gt;kvm, vpci-&gt;dev,</span><br><span class="line">                                   vpci-&gt;queue_selector,</span><br><span class="line">                                   ioport__read16(data));</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;操作3：设置被选择的common-queue的中断；和上面设置configure-queue一样；</span><br><span class="line">                case VIRTIO_PCI_COMMON_Q_MSIX:</span><br><span class="line">                    &#x2F;&#x2F;vec是msix-table中的索引号，例如common-queue-0的vec一般为1 (configure-queue的是0)，表示queue-0的中断路由信息是msix-table[1]；</span><br><span class="line">                    vec &#x3D; vpci-&gt;vq_vector[vpci-&gt;queue_selector] &#x3D; ioport__read16(data);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;gsi一般从24开始分配(0-23被irqchip占用)，各个PCI设备，各个queue(包括configure-queue)都不重合</span><br><span class="line">                    gsi &#x3D; virtio_pci__add_msix_route(vpci, vec);</span><br><span class="line">                          &#123;</span><br><span class="line">                              irq__add_msix_route()</span><br><span class="line">                              &#123;</span><br><span class="line">                                  &#x2F;&#x2F;分配中断路由表的entry；</span><br><span class="line">                                  irq__allocate_routing_entry();</span><br><span class="line"></span><br><span class="line">                                  &#x2F;&#x2F;分配gsi；即全局变量next_gsi的当前值；每次递增1；</span><br><span class="line"></span><br><span class="line">                                  &#x2F;&#x2F;初始化中断路由表的entry；</span><br><span class="line">                                  &#x2F;&#x2F;...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                  irq__update_msix_routes()</span><br><span class="line">                                  &#123;</span><br><span class="line">                                      &#x2F;&#x2F;将更新过的中断路由表同步给kvm内核模块</span><br><span class="line">                                      return ioctl(kvm-&gt;vm_fd, KVM_SET_GSI_ROUTING, irq_routing);</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                    if (gsi &lt; 0)</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                    vpci-&gt;gsis[vpci-&gt;queue_selector] &#x3D; gsi;</span><br><span class="line">                    if (vdev-&gt;ops-&gt;notify_vq_gsi)</span><br><span class="line">                        vdev-&gt;ops-&gt;notify_vq_gsi(vpci-&gt;kvm, vpci-&gt;dev,</span><br><span class="line">                                     vpci-&gt;queue_selector, gsi);</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;操作4：enable&#x2F;disable被选择的common-queue；</span><br><span class="line">                case VIRTIO_PCI_COMMON_Q_ENABLE:</span><br><span class="line">                    val &#x3D; ioport__read16(data);</span><br><span class="line">                    if (val)</span><br><span class="line">                        virtio_pci_init_vq(vpci-&gt;kvm, vdev, vpci-&gt;queue_selector);</span><br><span class="line">                    else</span><br><span class="line">                        virtio_pci_exit_vq(vpci-&gt;kvm, vdev, vpci-&gt;queue_selector);</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; case ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程如图：</p>
<p><img src="build-msi-irq-routing-table.png" alt="figure3"></p>
<div style="text-align: center;"><em>图3: 构造MSI中断路由表</em></div>

<p>看一下中断路由表中的MSI表项：</p>
<ul>
<li>address_hi和address_lo就是地址的高32位和低32位；一般情况下32位地址就够用了(所以address_hi为0)，64位地址对于MSI是可选特性，对于MSI-X是必须支持的特性(支持也不一定要使用)。这个地址映射到某个CPU的Local-APIC的寄存器。</li>
<li>data见第1.8节。这里kvmtool实现的应该是MSI-X，所以data是标识中断的，而不是标识PCI设备的(像MSI那样)。在触发中断的地方添加打印语句，发现PCI设备往给定addr上写的就是data本身，而不是data加上interrupt number(像MSI那样)。</li>
</ul>
<p>最后，看一下guest内的中断触以及PCI设备：</p>
<p><img src="interrupt-and-pci-devices.png" alt="figure4"></p>
<div style="text-align: center;"><em>图4: Guest内的PCI设备和中断</em></div>

<ul>
<li>virtio0是网卡，使用了3个中断，gsi分别是26, 27, 28；其中26是configure-queue；virtio1是存储控制器，也就是虚拟盘，使用了2个中断，gsi分别是24, 25；其中24是configure-queue；注意，从代码中上看，每个设备最多可以用33个中断，实际上guest并没有使用这么多。设备定义自己使用多少queue，例如kvmtool中，blk设备写死使用1个queue(加上configure-queue共2个)；</li>
<li>第一个capability (40表示0x40=64?)是MSI-X；</li>
<li>Vector table(msix-table)在BAR=2上且偏移是0；PBA也在BAR=2上且偏移是0x210=528(msix-table的大小)；和代码对的上。</li>
<li>/proc/interrupts的第一列是MSI号，即System vector number，而不是interrupt vector number. 所以<strong>可以通过/proc/interrupts看设备各个queue触发的中断数，以及中断是否打散到各个CPU，对于物理设备也一样</strong>。</li>
<li>从图中还可以看到，virtio0(网卡)对应到IRQ 5，virtio1(存储控制器)对应到IRQ 6。一个IRQ再对应多个interrupt vector number?</li>
</ul>
<h1 id="kvm内核模块的中断模拟-5"><a href="#kvm内核模块的中断模拟-5" class="headerlink" title="kvm内核模块的中断模拟 (5)"></a>kvm内核模块的中断模拟 (5)</h1><p>如前所述，中断的模拟工作主要是在kvm内核模块中完成的：设备要触发中断，要请求kvm内核模块代劳(见第2节)。在kvm内核模块中，模拟了PIC(级联的8259A)以及APIC的功能，当然也包含MSI方式的中断注入。具体参考下列文章：</p>
<p><a target="_blank" rel="noopener" href="https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/08/27/kvm-interrupt-emulation">https://terenceli.github.io/%E6%8A%80%E6%9C%AF/2018/08/27/kvm-interrupt-emulation</a><br><a target="_blank" rel="noopener" href="https://luohao-brian.gitbooks.io/interrupt-virtualization/content/qemu-kvm-zhong-duan-xu-ni-hua-kuang-jia-fen-679028-4e0a29.html">https://luohao-brian.gitbooks.io/interrupt-virtualization/content/qemu-kvm-zhong-duan-xu-ni-hua-kuang-jia-fen-679028-4e0a29.html</a></p>
<h1 id="小结-6"><a href="#小结-6" class="headerlink" title="小结 (6)"></a>小结 (6)</h1><p>通过本文简单了解了MSI/MSI-X中断方式，也在kvmtool中看到它是如何工作的：1. 系统对PCI设备编程，告诉PCI设备msix-table；2. PCI设备发起中断时，向给定的地址写给定的数据(地址和数据都在msix-table中)。在虚拟环境下，中断的模拟其实不是在VMM(kvmtool)中实现的，而是在kvm内核模块中实现的，所以，PCI设备要发起中断，要请求kvm内核模块来完成。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>写的不错，有赏！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Yuanguo Huo 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Yuanguo Huo 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/virtualization/" rel="tag"># virtualization</a>
              <a href="/tags/kvm/" rel="tag"># kvm</a>
              <a href="/tags/kvmtool/" rel="tag"># kvmtool</a>
              <a href="/tags/interrupt/" rel="tag"># interrupt</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/22/virtualization-4-kvmtool-pci/" rel="prev" title="虚拟化入门笔记--kvmtool pci virtualization">
      <i class="fa fa-chevron-left"></i> 虚拟化入门笔记--kvmtool pci virtualization
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/08/31/virtualization-6-kvmtool-virtio/" rel="next" title="虚拟化入门笔记--kvmtool virtio设备">
      虚拟化入门笔记--kvmtool virtio设备 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          本站概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#x86%E4%B8%AD%E6%96%AD%E5%9B%9E%E9%A1%BE-1"><span class="nav-number">1.</span> <span class="nav-text">x86中断回顾 (1)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1-1"><span class="nav-number">1.1.</span> <span class="nav-text">名词解释 (1.1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9FIRQ-1-2"><span class="nav-number">1.2.</span> <span class="nav-text">如何产生IRQ (1.2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IRQ%E6%98%A0%E5%B0%84%E5%88%B0INT-1-3"><span class="nav-number">1.3.</span> <span class="nav-text">IRQ映射到INT (1.3)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99device%E5%85%B3%E8%81%94%E4%B8%80%E4%B8%AAIRQ-interrupt-routing-GSI-1-4"><span class="nav-number">1.4.</span> <span class="nav-text">如何给device关联一个IRQ (interrupt routing, GSI) (1.4)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GSI%E6%98%A0%E5%B0%84%E5%88%B0IRQ-1-5"><span class="nav-number">1.5.</span> <span class="nav-text">GSI映射到IRQ (1.5)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Message-Signaled-Interrupts-MSI-1-6"><span class="nav-number">1.6.</span> <span class="nav-text">Message Signaled Interrupts (MSI) (1.6)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-MSI-Works-1-7"><span class="nav-number">1.7.</span> <span class="nav-text">How MSI Works (1.7)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MSI%E5%92%8CMSI-X-1-8"><span class="nav-number">1.8.</span> <span class="nav-text">MSI和MSI-X (1.8)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E8%99%9A%E6%8B%9F%E5%8C%96-2"><span class="nav-number">2.</span> <span class="nav-text">中断虚拟化 (2)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E5%BB%BAIRQCHIP%E4%B8%AD%E6%96%AD%E8%B7%AF%E7%94%B1%E8%A1%A8-3"><span class="nav-number">3.</span> <span class="nav-text">构建IRQCHIP中断路由表 (3)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E5%BB%BAMSI%E4%B8%AD%E6%96%AD%E8%B7%AF%E7%94%B1%E8%A1%A8-4"><span class="nav-number">4.</span> <span class="nav-text">构建MSI中断路由表 (4)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PCI%E7%9A%84Capability-List-4-1"><span class="nav-number">4.1.</span> <span class="nav-text">PCI的Capability-List (4.1)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MSI-Capability-4-2"><span class="nav-number">4.2.</span> <span class="nav-text">MSI-Capability (4.2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kvmtool%E7%9A%84%E5%AE%9E%E7%8E%B0-4-3"><span class="nav-number">4.3.</span> <span class="nav-text">kvmtool的实现 (4.3)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8capability-msix-4-3-1"><span class="nav-number">4.3.1.</span> <span class="nav-text">启用capability msix (4.3.1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9PCI%E8%AE%BE%E5%A4%87%E7%BC%96%E7%A8%8B%E8%AE%BE%E7%BD%AEPCI%E8%AE%BE%E5%A4%87%E7%9A%84msix-table-4-3-2"><span class="nav-number">4.3.2.</span> <span class="nav-text">对PCI设备编程设置PCI设备的msix table (4.3.2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%AD%E6%96%AD%E8%B7%AF%E7%94%B1%E8%A1%A8%E5%B9%B6%E5%90%8C%E6%AD%A5%E7%BB%99kvm-4-3-3"><span class="nav-number">4.3.3.</span> <span class="nav-text">构建中断路由表并同步给kvm (4.3.3)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kvm%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%AD%E6%96%AD%E6%A8%A1%E6%8B%9F-5"><span class="nav-number">5.</span> <span class="nav-text">kvm内核模块的中断模拟 (5)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="nav-number">6.</span> <span class="nav-text">小结 (6)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuanguo Huo"
      src="/images/me.gif">
  <p class="site-author-name" itemprop="name">Yuanguo Huo</p>
  <div class="site-description" itemprop="description">A little better than yesterday</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanguohuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanguohuo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanguo.h001@gmail.com" title="E-Mail → mailto:yuanguo.h001@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanguo Huo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"sKs2IrqwziD8hQqWqhcBdmxB-gzGzoHsz","app_key":"j2NAkBzz8pzcwkRlYdi87QEY","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'sKs2IrqwziD8hQqWqhcBdmxB-gzGzoHsz',
      appKey     : 'j2NAkBzz8pzcwkRlYdi87QEY',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>

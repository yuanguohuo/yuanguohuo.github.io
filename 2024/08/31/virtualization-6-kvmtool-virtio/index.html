<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文介绍kvmtool中对virtio的实现。前文interrupt virtualization留下一个问题，启用virtio device的queue到底做了什么事，本文一并回答。">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟化入门笔记--kvmtool virtio设备">
<meta property="og:url" content="http://yoursite.com/2024/08/31/virtualization-6-kvmtool-virtio/index.html">
<meta property="og:site_name" content="Yuanguo&#39;s Blog">
<meta property="og:description" content="本文介绍kvmtool中对virtio的实现。前文interrupt virtualization留下一个问题，启用virtio device的queue到底做了什么事，本文一并回答。">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2024/08/31/virtualization-6-kvmtool-virtio/virtio-components.png">
<meta property="og:image" content="http://yoursite.com/2024/08/31/virtualization-6-kvmtool-virtio/pass-available-buffer-to-dev.png">
<meta property="og:image" content="http://yoursite.com/2024/08/31/virtualization-6-kvmtool-virtio/pass-used-buffer-to-guest.png">
<meta property="og:image" content="http://yoursite.com/2024/08/31/virtualization-6-kvmtool-virtio/synchronouse-notification.png">
<meta property="og:image" content="http://yoursite.com/2024/08/31/virtualization-6-kvmtool-virtio/asynchronouse-notification.png">
<meta property="article:published_time" content="2024-08-31T21:23:47.000Z">
<meta property="article:modified_time" content="2025-07-10T09:32:33.571Z">
<meta property="article:author" content="Yuanguo Huo">
<meta property="article:tag" content="virtualization">
<meta property="article:tag" content="kvm">
<meta property="article:tag" content="kvmtool">
<meta property="article:tag" content="virtio">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2024/08/31/virtualization-6-kvmtool-virtio/virtio-components.png">

<link rel="canonical" href="http://yoursite.com/2024/08/31/virtualization-6-kvmtool-virtio/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>虚拟化入门笔记--kvmtool virtio设备 | Yuanguo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yuanguo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/08/31/virtualization-6-kvmtool-virtio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.gif">
      <meta itemprop="name" content="Yuanguo Huo">
      <meta itemprop="description" content="A little better than yesterday">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuanguo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          虚拟化入门笔记--kvmtool virtio设备
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="Created: 2024-08-31 21:23:47" itemprop="dateCreated datePublished" datetime="2024-08-31T21:23:47+00:00">2024-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="Modified: 2025-07-10 09:32:33" itemprop="dateModified" datetime="2025-07-10T09:32:33+00:00">2025-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">所属分类</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kvm/" itemprop="url" rel="index"><span itemprop="name">kvm</span></a>
                </span>
            </span>

          
            <span id="/2024/08/31/virtualization-6-kvmtool-virtio/" class="post-meta-item leancloud_visitors" data-flag-title="虚拟化入门笔记--kvmtool virtio设备" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/08/31/virtualization-6-kvmtool-virtio/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/08/31/virtualization-6-kvmtool-virtio/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文介绍kvmtool中对virtio的实现。<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/08/11/virtualization-5-kvmtool-interrupt/">前文interrupt virtualization</a>留下一个问题，启用virtio device的queue到底做了什么事，本文一并回答。</p>
<a id="more"></a>

<h1 id="virtio的组件-1"><a href="#virtio的组件-1" class="headerlink" title="virtio的组件 (1)"></a>virtio的组件 (1)</h1><p>在本文中，不打算从virtio specification出发去介绍virtio，而是直接从kvmtool的代码出发，结合virtio-blk以及virtio-scsi，看virtio是如何工作的。当然，我也会尽可能去概括virtio设备的一般特征。</p>
<p>Virtio包括两个组件：guest中的driver和host中的device。VMM(kvmtool,qemu)将virtio device暴露给guest的transport有多种(如PCI, Memory Mapping I/O, S/390 Channel I/O)，PCI是最常见的选择，所以本文特指PCI transport实现的virtio。</p>
<p>对于guest来讲，virtio设备就像真PCI设备一样：Real PCI hardware exposes its configuration space using a specific physical memory address range (i.e., the driver can read or write the device’s registers by accessing that memory range) and/or special processor instructions. In the VM world, the VMM (kvmtool,qemu) captures accesses to that memory range and performs device emulation, exposing the same memory layout that a real PCI device would have and offering the same responses. The virtio specification also defines the layout of its PCI Configuration space, so implementing it is straightforward. 参考<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/07/22/virtualization-4-kvmtool-pci/">pci virtualization</a>.</p>
<p>When the guest boots and uses the PCI/PCIe auto discovering mechanism, the virtio devices identify themselves wit the PCI vendor ID and their PCI Device ID (在PCI设备enumeration时，虚拟设备返回虚拟的vendorID和deviceID). The guest’s kernel uses these identifiers to know which driver must handle the device。</p>
<p>也就是，通过PCI vendorID和deviceID找driver(这和物理设备一样)，只不过vendorID和deviceID是虚拟出来的。我观察到的所有virtio device的vendorID都是0x1af4 (Red Hat, Inc.)；deviceID 0x1003是virtio console, 0x1001是SCSI storage controller等等，可以在<a target="_blank" rel="noopener" href="https://www.pcilookup.com/">pcilookup网站</a>上查询。</p>
<p>因为有各种类型的virtio设备(blk, net, …)，所以本文把guest中的driver记作<strong>virtio-x driver</strong>，把host中的device记作<strong>virtio-x device</strong>。另外，为了衔接vhost和qemu，这里也把virtio-x device分成<strong>control plane</strong>和<strong>data plane</strong>两个部分————其实在kvmtool的实现中这个两部分没有明显的模块化。Control plane指virtio设备的初始化和配置等管理功能，让guest感觉到那里有一个设备。Data plane是设备的数据处理功能，例如virtio-blk设备能够存取数据，virtio-net设备能够收发数据包，让guest真的能使用那个设备的功能。Control plane都是在VMM(kvmtool,qemu)中，而为了提升性能，data plane常被offload到host的内核(vhost)或者host的用户态进程(vhost-user)。这也是我们把virtio-x device强行分成两部分的原因。</p>
<p><img src="virtio-components.png" alt="figure1"></p>
<div style="text-align: center;"><em>图1: virtio的组件</em></div>

<h1 id="vring-2"><a href="#vring-2" class="headerlink" title="vring (2)"></a>vring (2)</h1><p>在<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/08/11/virtualization-5-kvmtool-interrupt/">interrupt virtualization</a>中经常看到queue。现代PCI设备都是多queue的，每个queue有独立的中断；这样就可以让多个CPU来处理中断，实现性能提升。到虚拟化领域，virtio设备也有多个queue，叫virt-queue。每个virt-queue也有独立的中断。</p>
<p>当然，queue/virt-queue的作用是数据传输。就virt-queue而言，数据传输是vring完成。在很多文章中，virt-queue和vring经常混用，搞不清它们的关系。在kvmtool中可以明确的看到：一个virtio设备有多个virt-queue；每个virt-queue有一个vring；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scsi_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virt_queue</span>        <span class="title">vqs</span>[<span class="title">NUM_VIRT_QUEUES</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_scsi_config</span>    <span class="title">config</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vhost_scsi_target</span>    <span class="title">target</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                vhost_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_device</span>        <span class="title">vdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm</span>            *<span class="title">kvm</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virt_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vring</span>    <span class="title">vring</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vring_addr</span> <span class="title">vring_addr</span>;</span></span><br><span class="line">    <span class="comment">/* The last_avail_idx field is an index to -&gt;ring of struct vring_avail.</span></span><br><span class="line"><span class="comment">       It&#x27;s where we assume the next request index is at.  */</span></span><br><span class="line">    u16        last_avail_idx;</span><br><span class="line">    u16        last_used_signalled;</span><br><span class="line">    u16        endian;</span><br><span class="line">    <span class="keyword">bool</span>        use_event_idx;</span><br><span class="line">    <span class="keyword">bool</span>        enabled;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_device</span> *<span class="title">vdev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* vhost IRQ handling */</span></span><br><span class="line">    <span class="keyword">int</span>        gsi;</span><br><span class="line">    <span class="keyword">int</span>        irqfd;</span><br><span class="line">    <span class="keyword">int</span>        index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Vring传输数据的方式是共享内存(见下一节)。它在两个方向传输数据：</p>
<ul>
<li>virtio-x driver向virtio-x device发送available-buffer;</li>
<li>virtio-x device向virtio-x driver发送used-buffer;</li>
</ul>
<p>为了高效地完成这个任务，vring设计上分为3个区：Descriptor-Area, Driver-Area (avail-queue), Device-Area (used-queue). Descriptor-Area描述一些内存buffer，逻辑上没有顺序；Driver-Area是virtio-x driver维护的，它通过引用的方式，把Descriptor-Area内的一些buffer组织成queue，也就是available-buffer queue，传递给virtio-x device。类似地，Device-Area是virtio-x device维护的，通过引用的方式，把Descriptor-Area内的一些buffer组织成queue，也就是used-buffer queue，传递给virtio-x driver。<a target="_blank" rel="noopener" href="https://www.redhat.com/en/blog/virtqueues-and-virtio-ring-how-data-travels">这篇文章</a>细讲了数据如何传输。这里仅通过2张图说明。</p>
<p>注意<strong>available/used</strong>这对用词，它的选取视角是guest作producer，device作consumer。对于output操作比如符合直觉：available-buffer中存着待输出的数据，输出到device之后，就变成used/consumed；对于input操作有点反直觉：available-buffer是空的，写入数据之后变成used/consumed。</p>
<p>A buffer can be read-only or write-only from the device point of view, but never both.</p>
<p><img src="pass-available-buffer-to-dev.png" alt="figure2"></p>
<div style="text-align: center;"><em>图2: guest pass available-buffer to virtio device</em></div>

<p>说明：</p>
<ul>
<li>Driver Area是virtio-x driver传递给virtio-x device的available buffer queue；</li>
<li>flags的最低位告诉virtio device消费完buffer之后，要不要interrupt guest；不是强制的，只是一个优化；</li>
<li>[k, k+1, m]是一个chained buffer，在available ring中只记它的head；</li>
<li>idx：队尾的下一个位置。其实就是用来标记队尾。队头就是<code>struct virt_queue</code>中的<code>last_avail_idx</code>。有了队头和队尾，自然可以判断队列是否位空、并从队列中取出元素。</li>
</ul>
<p><img src="pass-used-buffer-to-guest.png" alt="figure3"></p>
<div style="text-align: center;"><em>图3: virtio device pass used-buffer to guest </em></div>

<p>说明：</p>
<ul>
<li>Device Area是virtio-x device传递给virtio-x driver的used buffer queue；</li>
<li>对于写操作，一个buffer可能被部分消费(short write)；如图中的buffer j和k；</li>
<li>flags的最低位告诉guest的driver，要不要notify设备；不是强制的，只是一个优化；</li>
<li>[k, k+1, m] 是一个chained buffer，在used ring中也只记它的head；</li>
<li>设备不修改descriptor area；</li>
<li>idx；队尾的下一个位置。其实就是用来标记队尾。</li>
</ul>
<h1 id="vring的内存共享-3"><a href="#vring的内存共享-3" class="headerlink" title="vring的内存共享 (3)"></a>vring的内存共享 (3)</h1><p>前面说过，vring传递数据的方式是共享内存(高效)。内存是virtio-x driver在guest的内核里分配的，VMM(qemu,kvmtool)能够访问的到，因为guest的内存在VMM进程的内存空间里。所以：</p>
<ul>
<li>若virtio-x device整个是在VMM中模拟的，则可以直接访问(地址的translation还是必要的，从little-endian转换成host的cpu-endian；little-endian是virtio协议定义的吗？)；</li>
<li>若virtio-x device的data plane被offload，则需要地址映射：like POSIX shared memory; a file descriptor to that memory is shared through vhost protocol；</li>
</ul>
<p>无论如何，VMM(qemu,kvmtool)需要拿到内存的地址(若offload，VMM再把地址共享给data plane，待确认)。Virtio的common capability可以实现这一点，<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/08/11/virtualization-5-kvmtool-interrupt/">interrupt virtualization</a>的第4.3.3节提到<strong>guest发送被选择的common-queue的vring的地址给device</strong>，就是这个实现。</p>
<p>Kvmtool方面：实现了common capability，即在configuration space中填写了virtio common capability的相关配置(见virtio/pci-modern.c:virtio_pci_modern_init函数)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">virtio_pci_modern_init</span><span class="params">(struct virtio_device *vdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> subsys_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> *<span class="title">vpci</span> = <span class="title">vdev</span>-&gt;<span class="title">virtio</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_header</span> *<span class="title">hdr</span> = &amp;<span class="title">vpci</span>-&gt;<span class="title">pci_hdr</span>;</span></span><br><span class="line"></span><br><span class="line">    subsys_id = le16_to_cpu(hdr-&gt;subsys_id);</span><br><span class="line"></span><br><span class="line">    hdr-&gt;device_id = cpu_to_le16(PCI_DEVICE_ID_VIRTIO_BASE + subsys_id);</span><br><span class="line">    hdr-&gt;subsys_id = cpu_to_le16(PCI_SUBSYS_ID_VIRTIO_BASE + subsys_id);</span><br><span class="line"></span><br><span class="line">    vpci-&gt;doorbell_offset = VPCI_CFG_NOTIFY_START;</span><br><span class="line">    vdev-&gt;endian = VIRTIO_ENDIAN_LE;</span><br><span class="line"></span><br><span class="line">    hdr-&gt;msix.next = PCI_CAP_OFF(hdr, virtio);</span><br><span class="line"></span><br><span class="line">    hdr-&gt;virtio.common = (struct virtio_pci_cap) &#123;</span><br><span class="line">        .cap_vndr        = PCI_CAP_ID_VNDR,</span><br><span class="line">        .cap_next        = PCI_CAP_OFF(hdr, virtio.notify),</span><br><span class="line">        .cap_len        = <span class="keyword">sizeof</span>(hdr-&gt;virtio.common),</span><br><span class="line">        .cfg_type        = VIRTIO_PCI_CAP_COMMON_CFG,</span><br><span class="line">        .bar            = <span class="number">1</span>,</span><br><span class="line">        .offset            = cpu_to_le32(VPCI_CFG_COMMON_START),</span><br><span class="line">        .length            = cpu_to_le32(VPCI_CFG_COMMON_SIZE),</span><br><span class="line">    &#125;;</span><br><span class="line">    BUILD_BUG_ON(VPCI_CFG_COMMON_START &amp; <span class="number">0x3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Guest方面：从device的configuration space读到这个配置，知道device启用了virtio common capability，就写对应的BAR-region (偏移<code>VPCI_CFG_COMMON_START</code>处)，传递过来vring的各个area的地址。</p>
<p>在kvmtool中，BAR-0和BAR-1的region都支持这个操作，它们注册的callback都是<code>virtio_pci_modern__io_mmio_callback</code>，只是io-port map和memory map的不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">virtio_pci_modern__io_mmio_callback</span><span class="params">(struct kvm_cpu *vcpu, u64 addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                     u8 *data, u32 len, u8 is_write,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_device</span> *<span class="title">vdev</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> *<span class="title">vpci</span> = <span class="title">vdev</span>-&gt;<span class="title">virtio</span>;</span></span><br><span class="line">    u32 mmio_addr = virtio_pci__mmio_addr(vpci);</span><br><span class="line"></span><br><span class="line">    virtio_pci_access(vcpu, vdev, addr - mmio_addr, data, len, is_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">virtio_pci_access</span><span class="params">(struct kvm_cpu *vcpu, struct virtio_device *vdev,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">long</span> offset, <span class="keyword">void</span> *data, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">bool</span> write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">access_handler_t</span> handler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (offset) &#123;</span><br><span class="line">    <span class="keyword">case</span> VPCI_CFG_COMMON_START...VPCI_CFG_COMMON_END:</span><br><span class="line">        <span class="keyword">if</span> (write)</span><br><span class="line">            handler = virtio_pci__common_write;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            handler = virtio_pci__common_read;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handler)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handler(vdev, offset, data, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">virtio_pci__common_write</span><span class="params">(struct virtio_device *vdev,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">long</span> offset, <span class="keyword">void</span> *data, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 features;</span><br><span class="line">    u32 val, gsi, vec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> *<span class="title">vpci</span> = <span class="title">vdev</span>-&gt;<span class="title">virtio</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (offset - VPCI_CFG_COMMON_START) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_DESCLO:</span><br><span class="line">        vpci_selected_vq(vpci)-&gt;vring_addr.desc_lo = ioport__read32(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_DESCHI:</span><br><span class="line">        vpci_selected_vq(vpci)-&gt;vring_addr.desc_hi = ioport__read32(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_AVAILLO:</span><br><span class="line">        vpci_selected_vq(vpci)-&gt;vring_addr.avail_lo = ioport__read32(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_AVAILHI:</span><br><span class="line">        vpci_selected_vq(vpci)-&gt;vring_addr.avail_hi = ioport__read32(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_USEDLO:</span><br><span class="line">        vpci_selected_vq(vpci)-&gt;vring_addr.used_lo = ioport__read32(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_USEDHI:</span><br><span class="line">        vpci_selected_vq(vpci)-&gt;vring_addr.used_hi = ioport__read32(data);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中<code>desc_hi/desc_lo</code>，<code>avail_hi/avail_lo</code>，<code>used_hi/used_lo</code>分别是Descriptor-Area，Driver-Area和Device-Area的地址(高32位和低32位)。</p>
<h1 id="通知机制-4"><a href="#通知机制-4" class="headerlink" title="通知机制 (4)"></a>通知机制 (4)</h1><p>在第2节看到vring在两个方向上传输数据；与之对应，需要两个方向上的通知。The virtio specification defines bi-directional notifications:</p>
<ul>
<li>available-buffer notification: the virtio-x driver notifies the virtio-x device that there are buffers in the vring that are ready to be processed;</li>
<li>used-buffer notification: the virtio-x device signals the virtio-x driver that it has finished processing some buffers;</li>
</ul>
<p>In the PCI case, the guest sends the available-buffer notification by writing to a specific memory address, and the device uses a vCPU interrupt to send the used buffer notification.</p>
<p>注：引入vhost之后，data plane主动poll vring，不需要available-buffer notification。而guest中的virtio-x driver，若是内核态的，应该还依赖used-buffer notification；若guest中采用用户态driver(如SPDK的用户态nvme driver)，就不依赖了。</p>
<p>名词约定：在kvmtool的代码中，available-buffer notification用的是<strong>notify</strong>一词；而used-buffer notification用的是<strong>signal</strong>一词(即interrupt)。</p>
<h2 id="Available-buffer-notification-4-1"><a href="#Available-buffer-notification-4-1" class="headerlink" title="Available-buffer notification (4.1)"></a>Available-buffer notification (4.1)</h2><p>The guest (virtio-x driver) sends the available buffer notification by writing to a specific memory address. 这是virtio的notify capability(和前面的common capability并列)，启用过程在virtio/pci-modern.c:virtio_pci_modern_init中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">virtio_pci_modern_init</span><span class="params">(struct virtio_device *vdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> subsys_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> *<span class="title">vpci</span> = <span class="title">vdev</span>-&gt;<span class="title">virtio</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_device_header</span> *<span class="title">hdr</span> = &amp;<span class="title">vpci</span>-&gt;<span class="title">pci_hdr</span>;</span></span><br><span class="line"></span><br><span class="line">    subsys_id = le16_to_cpu(hdr-&gt;subsys_id);</span><br><span class="line"></span><br><span class="line">    hdr-&gt;device_id = cpu_to_le16(PCI_DEVICE_ID_VIRTIO_BASE + subsys_id);</span><br><span class="line">    hdr-&gt;subsys_id = cpu_to_le16(PCI_SUBSYS_ID_VIRTIO_BASE + subsys_id);</span><br><span class="line"></span><br><span class="line">    vpci-&gt;doorbell_offset = VPCI_CFG_NOTIFY_START;</span><br><span class="line">    vdev-&gt;endian = VIRTIO_ENDIAN_LE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    hdr-&gt;virtio.notify = (struct virtio_pci_notify_cap) &#123;</span><br><span class="line">        .cap.cap_vndr        = PCI_CAP_ID_VNDR,</span><br><span class="line">        .cap.cap_next        = PCI_CAP_OFF(hdr, virtio.isr),</span><br><span class="line">        .cap.cap_len        = <span class="keyword">sizeof</span>(hdr-&gt;virtio.notify),</span><br><span class="line">        .cap.cfg_type        = VIRTIO_PCI_CAP_NOTIFY_CFG,</span><br><span class="line">        .cap.bar        = <span class="number">1</span>,</span><br><span class="line">        .cap.offset        = cpu_to_le32(VPCI_CFG_NOTIFY_START),</span><br><span class="line">        .cap.length        = cpu_to_le32(VPCI_CFG_NOTIFY_SIZE),</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Notify multiplier is 0, meaning that notifications are all on</span></span><br><span class="line"><span class="comment">         * the same register</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Guest从device的configuration space读到这个配置，知道device启用了notify capability，就写对应的BAR-region (偏移<code>VPCI_CFG_NOTIFY_START</code>处)，实现通知功能。在kvmtool中，BAR-0和BAR-1的region都支持这个操作，它们注册的callback都是<code>virtio_pci_modern__io_mmio_callback</code>，只是io-port map和memory map的不同。</p>
<h3 id="同步通知-4-1-1"><a href="#同步通知-4-1-1" class="headerlink" title="同步通知 (4.1.1)"></a>同步通知 (4.1.1)</h3><p>Virtio-x driver通过写BAR-region-0或者BAR-region-1(偏移<code>VPCI_CFG_NOTIFY_START</code>)通知device有available buffer可以处理。这时就触发kvmtool的<code>virtio_pci_modern__io_mmio_callback</code>函数，VM阻塞，所以通知是同步的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">virtio_pci_modern__io_mmio_callback</span><span class="params">(struct kvm_cpu *vcpu, u64 addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                     u8 *data, u32 len, u8 is_write,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_device</span> *<span class="title">vdev</span> = <span class="title">ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> *<span class="title">vpci</span> = <span class="title">vdev</span>-&gt;<span class="title">virtio</span>;</span></span><br><span class="line">    u32 mmio_addr = virtio_pci__mmio_addr(vpci);</span><br><span class="line"></span><br><span class="line">    virtio_pci_access(vcpu, vdev, addr - mmio_addr, data, len, is_write);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">virtio_pci_access</span><span class="params">(struct kvm_cpu *vcpu, struct virtio_device *vdev,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">long</span> offset, <span class="keyword">void</span> *data, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">bool</span> write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">access_handler_t</span> handler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (offset) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VPCI_CFG_NOTIFY_START...VPCI_CFG_NOTIFY_END:</span><br><span class="line">        <span class="keyword">if</span> (write)</span><br><span class="line">            handler = virtio_pci__notify_write;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handler)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handler(vdev, offset, data, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">virtio_pci__notify_write</span><span class="params">(struct virtio_device *vdev,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">long</span> offset, <span class="keyword">void</span> *data, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u16 vq = ioport__read16(data);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> *<span class="title">vpci</span> = <span class="title">vdev</span>-&gt;<span class="title">virtio</span>;</span></span><br><span class="line"></span><br><span class="line">    vdev-&gt;ops-&gt;notify_vq(vpci-&gt;kvm, vpci-&gt;dev, vq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知消息中只包含virt queue number；因为buffer在vring中，这里只要告诉device vring里有数据就行了。</p>
<p><img src="synchronouse-notification.png" alt="figure4"></p>
<div style="text-align: center;"><em>图4: 同步通知</em></div>

<h3 id="异步通知-4-1-2"><a href="#异步通知-4-1-2" class="headerlink" title="异步通知 (4.1.2)"></a>异步通知 (4.1.2)</h3><p>Virtio-x driver把通知写到ioeventfd中，然后继续工作。通知消息可以缓存在ioeventfd中；virtio-x device异步地poll ioeventfd (注意和vhost poll vring不同)，批量地处理(batch)。</p>
<p>异步有更高的优先级，假如启用的话，同步方式就接收不到消息(我在kvmtool上实验过)。如何启用呢？这刚好填了前一篇<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/08/11/virtualization-5-kvmtool-interrupt/">interrupt virtualization</a>中第4.3.3节留下的坑：启用被选择的common-queue。Guest选择一个common-queue，配置中断，共享vring地址(前面第3节)之后就启用它，触发如下callback：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">virtio_pci__common_write</span><span class="params">(struct virtio_device *vdev,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">long</span> offset, <span class="keyword">void</span> *data, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 features;</span><br><span class="line">    u32 val, gsi, vec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> *<span class="title">vpci</span> = <span class="title">vdev</span>-&gt;<span class="title">virtio</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (offset - VPCI_CFG_COMMON_START) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> VIRTIO_PCI_COMMON_Q_ENABLE:</span><br><span class="line">        val = ioport__read16(data);</span><br><span class="line">        <span class="keyword">if</span> (val)</span><br><span class="line">            virtio_pci_init_vq(vpci-&gt;kvm, vdev, vpci-&gt;queue_selector);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            virtio_pci_exit_vq(vpci-&gt;kvm, vdev, vpci-&gt;queue_selector);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只看启用<code>virtio_pci_init_vq</code>：启用queue的主要任务是<code>vdev-&gt;ops-&gt;init_vq</code>，让device处理vring上的buffer。重点是<code>virtio_pci__init_ioeventfd</code>，它的任务是启用异步通知机制。如注释中所述，把它删掉也不影响功能，只是会使用同步通知方式而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">virtio_pci_init_vq</span><span class="params">(struct kvm *kvm, struct virtio_device *vdev, <span class="keyword">int</span> vq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> *<span class="title">vpci</span> = <span class="title">vdev</span>-&gt;<span class="title">virtio</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以跳过对virtio_pci__init_ioeventfd()的调用；</span></span><br><span class="line">    <span class="comment">//假如跳过，notification就会通过这个方式发送过来(就是4.1.1节中的同步通知方式)：</span></span><br><span class="line">    <span class="comment">//      virtio_pci_modern__io_mmio_callback() --&gt;</span></span><br><span class="line">    <span class="comment">//      virtio_pci_access()</span></span><br><span class="line">    <span class="comment">//      &#123;</span></span><br><span class="line">    <span class="comment">//        case VPCI_CFG_NOTIFY_START...VPCI_CFG_NOTIFY_END:</span></span><br><span class="line">    <span class="comment">//          virtio_pci__notify_write()</span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    ret = virtio_pci__init_ioeventfd(kvm, vdev, vq);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;couldn&#x27;t add ioeventfd for vq %d: %d&quot;</span>, vq, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vdev-&gt;ops-&gt;init_vq(kvm, vpci-&gt;dev, vq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>virtio_pci__init_ioeventfd</code>主要做的事情是：</p>
<ul>
<li>创建一个eventfd实例，叫做ioeventfd；</li>
<li>构造一个<code>struct kvm_ioeventfd</code>实例<code>kvm_ioevent</code>: {.addr=BAR-region起始地址+VIRTIO_PCI_QUEUE_NOTIFY; .fd=ioeventfd;}</li>
<li>通过<code>ioctl(vm_fd, KVM_IOEVENTFD, &amp;kvm_ioevent)</code>，告诉kvm内核模块；</li>
</ul>
<p>就是告诉内kvm模块：本该通过写BAR-region(偏移<code>地址+VIRTIO_PCI_QUEUE_NOTIFY</code>)发送的通知(第4.1.1节的方式)，现在通过ioeventfd发(可以被缓存，然后批量地处理)。看！它们的地址是相同的：<code>BAR-region起始地址+VIRTIO_PCI_QUEUE_NOTIFY</code>！</p>
<p>另外，在kvmtool中BAR-0和BAR-1的功能是相同的(只是一个io-port map另一个memory map)，所以上述过程对BAR-0和BAR-1分别执行一遍。</p>
<p><img src="asynchronouse-notification.png" alt="figure5"></p>
<div style="text-align: center;"><em>图5: 异步通知</em></div>

<p>注意：异步通知可以实现批处理，性能应该比同步通知更高；虽然它也是通过poll实现的，但和vhost poll vring不同，后者不需要通知，更高效。</p>
<h2 id="Used-buffer-notification-4-2"><a href="#Used-buffer-notification-4-2" class="headerlink" title="Used-buffer notification (4.2)"></a>Used-buffer notification (4.2)</h2><p>The virtio-x device uses a vCPU interrupt to send the used buffer notification.</p>
<p>前一章<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/08/11/virtualization-5-kvmtool-interrupt/">interrupt virtualization</a>已经说到，要给guest发中断需要请求kvm内核模块来完成：</p>
<ul>
<li>对于irqchip方式：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(kvm-&gt;vm_fd, KVM_IRQ_LINE, &#123;.irq=gsi&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>对于msi方式:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(kvm-&gt;vm_fd, KVM_SIGNAL_MSI, &#123;.address_lo=addr_lo .address_hi=addr_hi, .data=data&#125;);</span><br></pre></td></tr></table></figure>

<p>以virtio-blk为例，在处理完请求之后，发起中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_blk_do_io</span><span class="params">(struct kvm *kvm, struct virt_queue *vq, struct blk_dev *bdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_req</span> *<span class="title">req</span>;</span></span><br><span class="line">    u16 head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查avaiable-buffer queue是否不空</span></span><br><span class="line">    <span class="keyword">while</span> (virt_queue__available(vq)) &#123;</span><br><span class="line">        <span class="comment">//获取avaiable-buffer queue的head；它是Descriptor Area表的index；</span></span><br><span class="line">        head        = virt_queue__pop(vq);</span><br><span class="line">        <span class="comment">//reqs和Descriptor Area表一一对应；</span></span><br><span class="line">        req        = &amp;bdev-&gt;reqs[head];</span><br><span class="line">        <span class="comment">//从Descriptor Area的表项中得到buffer的地址和长度，放到req-&gt;iov中，并不拷贝buffer本身；</span></span><br><span class="line">        req-&gt;head    = virt_queue__get_head_iov(vq, req-&gt;iov, &amp;req-&gt;out,</span><br><span class="line">                    &amp;req-&gt;in, head, kvm);</span><br><span class="line">        req-&gt;vq        = vq;</span><br><span class="line"></span><br><span class="line">        virtio_blk_do_io_request(kvm, vq, req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_blk_do_io_request</span><span class="params">(struct kvm *kvm, struct virt_queue *vq, struct blk_dev_req *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_blk_outhdr</span> <span class="title">req_hdr</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> iovcount, last_iov;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_dev</span> *<span class="title">bdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> len;</span><br><span class="line">    u32 type;</span><br><span class="line">    u64 sector;</span><br><span class="line"></span><br><span class="line">    bdev        = req-&gt;bdev;</span><br><span class="line">    iov        = req-&gt;iov;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_BLK_T_IN:</span><br><span class="line">        disk_image__read(bdev-&gt;disk, sector, iov, iovcount, req);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_BLK_T_OUT:</span><br><span class="line">        disk_image__write(bdev-&gt;disk, sector, iov, iovcount, req);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_BLK_T_FLUSH:</span><br><span class="line">        len = disk_image__flush(bdev-&gt;disk);</span><br><span class="line">        virtio_blk_complete(req, len);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> VIRTIO_BLK_T_GET_ID:</span><br><span class="line">        len = disk_image__get_serial(bdev-&gt;disk, iov, iovcount,</span><br><span class="line">                         VIRTIO_BLK_ID_BYTES);</span><br><span class="line">        virtio_blk_complete(req, len);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        pr_warning(<span class="string">&quot;request type %d&quot;</span>, type);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">virtio_blk_complete</span><span class="params">(<span class="keyword">void</span> *param, <span class="keyword">long</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_req</span> *<span class="title">req</span> = <span class="title">param</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_dev</span> *<span class="title">bdev</span> = <span class="title">req</span>-&gt;<span class="title">bdev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> queueid = req-&gt;vq - bdev-&gt;vqs;</span><br><span class="line">    u8 *status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* status */</span></span><br><span class="line">    status = req-&gt;status;</span><br><span class="line">    *status    = (len &lt; <span class="number">0</span>) ? VIRTIO_BLK_S_IOERR : VIRTIO_BLK_S_OK;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;bdev-&gt;mutex);</span><br><span class="line">    <span class="comment">//used-buffer放进queue</span></span><br><span class="line">    virt_queue__set_used_elem(req-&gt;vq, req-&gt;head, len);</span><br><span class="line">    mutex_unlock(&amp;bdev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发中断；对于PCI transport，signal_vq指向virtio_pci__signal_vq()函数；</span></span><br><span class="line">    <span class="keyword">if</span> (virtio_queue__should_signal(&amp;bdev-&gt;vqs[queueid]))</span><br><span class="line">        bdev-&gt;vdev.ops-&gt;signal_vq(req-&gt;kvm, &amp;bdev-&gt;vdev, queueid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">virtio_pci__signal_vq</span><span class="params">(struct kvm *kvm, struct virtio_device *vdev, u32 vq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtio_pci</span> *<span class="title">vpci</span> = <span class="title">vdev</span>-&gt;<span class="title">virtio</span>;</span></span><br><span class="line">    <span class="keyword">int</span> tbl = vpci-&gt;vq_vector[vq];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (virtio_pci__msix_enabled(vpci) &amp;&amp; tbl != VIRTIO_MSI_NO_VECTOR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vpci-&gt;pci_hdr.msix.ctrl &amp; cpu_to_le16(PCI_MSIX_FLAGS_MASKALL) ||</span><br><span class="line">            vpci-&gt;msix_table[tbl].ctrl &amp; cpu_to_le16(PCI_MSIX_ENTRY_CTRL_MASKBIT)) &#123;</span><br><span class="line"></span><br><span class="line">            vpci-&gt;msix_pba |= <span class="number">1</span> &lt;&lt; tbl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vpci-&gt;signal_msi)</span><br><span class="line">            virtio_pci__signal_msi(kvm, vpci, vpci-&gt;vq_vector[vq]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            kvm__irq_trigger(kvm, vpci-&gt;gsis[vq]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟边沿触发，所以发一个高电平加一个低电平</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvm__irq_trigger</span><span class="params">(struct kvm *kvm, <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kvm__irq_line(kvm, irq, <span class="number">1</span>);</span><br><span class="line">    kvm__irq_line(kvm, irq, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">virtio_pci__signal_msi</span><span class="params">(struct kvm *kvm, struct virtio_pci *vpci,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kvm_msi</span> <span class="title">msi</span> = &#123;</span></span><br><span class="line">        .address_lo = vpci-&gt;msix_table[vec].msg.address_lo,</span><br><span class="line">        .address_hi = vpci-&gt;msix_table[vec].msg.address_hi,</span><br><span class="line">        .data = vpci-&gt;msix_table[vec].msg.data,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kvm-&gt;msix_needs_devid) &#123;</span><br><span class="line">        msi.flags = KVM_MSI_VALID_DEVID;</span><br><span class="line">        msi.devid = vpci-&gt;dev_hdr.dev_num &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    irq__signal_msi(kvm, &amp;msi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The virtio specification also allows the notifications to be enabled or disabled dynamically. That way, devices and drivers can batch buffer notifications (异步通知) or even actively poll for new buffers in virtqueues (busy polling, vhost). This approach is better suited for high traffic rates.</p>
<p>也就是说，两端都能够使用polling模式：</p>
<ul>
<li>virtio-x driver端：guest里不使用内核态virtio-x driver，而是使用用户态driver，例如SPDK的用户态nvme driver；</li>
<li>virtio-x device端：vhost；注意vhost poll vring和poll ioeventfd不同；</li>
</ul>
<h1 id="低效问题-5"><a href="#低效问题-5" class="headerlink" title="低效问题 (5)"></a>低效问题 (5)</h1><p>从前面图1,4,5可见，data plane在VMM(kvmtool,qemu)中，即用户态进程中，这带来一些效率问题：</p>
<ul>
<li>virtio-x driver发完available-buffer notification，vCPU停止运行，转到VMM(kvmtool,qemu)用户态进程(异步通知模式应该不会)。这有个内核态到用户态的context switch；</li>
<li>通常情况下，VMM(virtio-x device)还是要借助host kernel的能力来处理数据，这就有用户态到内核态的数据拷贝。例如，VMM中的虚拟网卡要把数据拷贝到host内核态的tap；VMM中的blk要把数据拷贝到内核态驱动。</li>
<li>VMM(virtio-x device)给virtio-x driver发中断，要使用ioctl，它是一个系统调用，所以有用户态到内核态再返回用户态的context switch；</li>
<li>因为vCPU停止运行了，还需要一个系统调用来resume vCPU，也是有用户态到内核态再返回用户态的context switch；</li>
</ul>
<p>这所有的低效都因为data plane在VMM中。假如data plane在host的内核中，那么context switch就没有了，并且也不存在用户态到内核态的数据拷贝问题：通过一些内存映射，vring中的buffer可以直接共享给内核里的data plane。这就是<a target="_blank" rel="noopener" href="https://www.yuanguohuo.com/2024/10/06/virtualization-8-kvmtool-vhost/">vhost</a>的内容。</p>
<h1 id="小结-6"><a href="#小结-6" class="headerlink" title="小结 (6)"></a>小结 (6)</h1><p>结合kvmtool中virtio-blk的实现，粗略学习virtio机制。其中的重点是virt-queue和两个方向上的通知(notify和interrupt)。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>写的不错，有赏！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Yuanguo Huo 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Yuanguo Huo 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/virtualization/" rel="tag"># virtualization</a>
              <a href="/tags/kvm/" rel="tag"># kvm</a>
              <a href="/tags/kvmtool/" rel="tag"># kvmtool</a>
              <a href="/tags/virtio/" rel="tag"># virtio</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/08/11/virtualization-5-kvmtool-interrupt/" rel="prev" title="虚拟化入门笔记--kvmtool interrupt virtualization">
      <i class="fa fa-chevron-left"></i> 虚拟化入门笔记--kvmtool interrupt virtualization
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/09/29/virtualization-7-kvmtool-virtio-blk/" rel="next" title="虚拟化入门笔记--kvmtool virtio-blk设备">
      虚拟化入门笔记--kvmtool virtio-blk设备 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          本站概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#virtio%E7%9A%84%E7%BB%84%E4%BB%B6-1"><span class="nav-number">1.</span> <span class="nav-text">virtio的组件 (1)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vring-2"><span class="nav-number">2.</span> <span class="nav-text">vring (2)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vring%E7%9A%84%E5%86%85%E5%AD%98%E5%85%B1%E4%BA%AB-3"><span class="nav-number">3.</span> <span class="nav-text">vring的内存共享 (3)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6-4"><span class="nav-number">4.</span> <span class="nav-text">通知机制 (4)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Available-buffer-notification-4-1"><span class="nav-number">4.1.</span> <span class="nav-text">Available-buffer notification (4.1)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%80%9A%E7%9F%A5-4-1-1"><span class="nav-number">4.1.1.</span> <span class="nav-text">同步通知 (4.1.1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5-4-1-2"><span class="nav-number">4.1.2.</span> <span class="nav-text">异步通知 (4.1.2)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Used-buffer-notification-4-2"><span class="nav-number">4.2.</span> <span class="nav-text">Used-buffer notification (4.2)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8E%E6%95%88%E9%97%AE%E9%A2%98-5"><span class="nav-number">5.</span> <span class="nav-text">低效问题 (5)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="nav-number">6.</span> <span class="nav-text">小结 (6)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuanguo Huo"
      src="/images/me.gif">
  <p class="site-author-name" itemprop="name">Yuanguo Huo</p>
  <div class="site-description" itemprop="description">A little better than yesterday</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuanguohuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuanguohuo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanguo.h001@gmail.com" title="E-Mail → mailto:yuanguo.h001@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuanguo Huo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"sKs2IrqwziD8hQqWqhcBdmxB-gzGzoHsz","app_key":"j2NAkBzz8pzcwkRlYdi87QEY","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'sKs2IrqwziD8hQqWqhcBdmxB-gzGzoHsz',
      appKey     : 'j2NAkBzz8pzcwkRlYdi87QEY',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
